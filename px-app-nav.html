<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-dropdown/iron-dropdown.html" />
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html" />
<link rel="import" href="../iron-media-query/iron-media-query.html" />

<link rel="import" href="px-app-nav-group.html" />
<link rel="import" href="px-app-nav-subgroup.html" />
<link rel="import" href="px-app-nav-item.html" />

<!--

#### Usage

    <px-app-nav
        nav-items='[{"path": "", "icon": "fa-exclamation-triangle", "label":"//alerts","subitems": [{"label": "Sub Category 1"}, {"label": "Sub Category 2"}]},{"path": "tab2", "icon": "fa-briefcase", "label": "Cases"}]'
            <any-arbitrary-content></any-arbitrary-content>
            <div class="auth">
                <any-auth-control></any-auth-control>
            </div>
    </px-app-nav>

#### Styling
The following custom properties are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--px-app-nav-background-color` | Background color for the app navigation component | `$gray10`
`--px-app-nav-link-text-color` | Text color for the nav items | `$white`
`--px-app-nav-link-hover-color` | Background color for a nav item when a user hovers over one | `$gray8`
`--px-app-nav-link-selected-active-color` | Background color for a nav item when a user clicks on one | `$select-blue-hover`
`--px-app-nav-link-selected-color` | Background color for the selected nav item | `$select-blue-pressed`
`--px-app-nav-hamburger-button-color` | Fill color for the hamburger menu icon | `$white`

@element px-app-nav
@blurb Nav bar / drawer for applications.
@homepage index.html
@demo index.html
-->

<link rel="import" href="css/px-app-nav-styles.html">

<dom-module id="px-app-nav">
  <template>
    <style include="px-app-nav-styles"></style>

    <template is="dom-if" if="{{collapseAt}}" restamp>
      <iron-media-query query="{{collapseAt}}" query-matches="{{collapseAll}}"></iron-media-query>
    </template>

    <section class="app-nav" id="container">
      <section class="app-nav__items" id="items">
        <!-- First item stamp: visible items -->
        <template is="dom-repeat" items="{{items}}" filter="_isItemVisible" id="visible">
          <!-- Stamp groups, which hold subitems -->
          <template is="dom-if" if="{{_hasSubitems(item)}}">
            <px-app-nav-group label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}" selected$="{{_isItemSelected(item, selectedItem)}}">
              <template is="dom-repeat" items="{{item.subitems}}" as="subitem">
                <px-app-nav-item label="{{subitem.label}}" path="{{subitem.path}}" selected$="{{_isItemSelected(subitem, selectedSubitem)}}" subitem></px-app-nav-item>
              </template>
            </px-app-nav-group>
          </template>

          <!-- Stamp plain old items, which hold subitems -->
          <template is="dom-if" if="{{_hasNoSubitems(item)}}">
            <px-app-nav-item label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}" selected$="{{_isItemSelected(item, selectedItem)}}">
            </px-app-nav-item>
          </template>
        </template>

        <!-- STATE: Items overflowed or collapsed -->
        <template is="dom-if" if="{{_anyOverflowed(overflowedItems, visibleItems)}}">
          <px-app-nav-group
              superlist
              fixed-width="[[_getDropdownWidth(collapseWidth, allCollapsed)]]"
              id="overflowedGroup"
              label="{{_getDropdownLabel(selectedItem, collapseWithIcon, allCollapsed)}}"
              icon="{{_getDropdownIcon(selectedItem, collapseWithIcon, allCollapsed, anyOverflowed, collapseOpened)}}"
              selected$="{{_ifSelectedOverflowed(selectedItem, overflowedItems)}}"
              hide-dropdown-icon="{{_shouldHideDropdownCarat(allCollapsed, collapseWithIcon)}}"
              no-highlight="{{allCollapsed}}"
              empty="{{_isDropdownEmpty(selectedItem, allCollapsed, collapseWithIcon)}}"
              opened="{{collapseOpened}}">
            <!-- Second item stamp: overflowed/collapsed items -->
            <template is="dom-repeat" items="{{items}}" filter="_isItemOverflowed" id="overflowed">
              <!-- Stamp groups, which hold subitems -->
              <template is="dom-if" if="{{_hasSubitems(item)}}">
                <px-app-nav-subgroup label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}" selected$="{{_isItemSelected(item, selectedItem)}}" overflowed$="{{someOverflowed}}" collapsed$="{{allCollapsed}}">
                  <template is="dom-repeat" items="{{item.subitems}}" as="subitem">
                    <px-app-nav-item label="{{subitem.label}}" path="{{subitem.path}}" selected$="{{_isItemSelected(subitem, selectedSubitem)}}" parent-selected$="{{_isItemSelected(item, selectedItem)}}" subitem collapsed$="{{allCollapsed}}"></px-app-nav-item>
                  </template>
                </px-app-nav-subgroup>
              </template>

              <!-- Stamp plain old items, which hold subitems -->
              <template is="dom-if" if="{{_hasNoSubitems(item)}}">
                <px-app-nav-item label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}" selected$="{{_isItemSelected(item, selectedItem)}}" overflowed$="{{someOverflowed}}" collapsed$="{{allCollapsed}}">
                </px-app-nav-item>
              </template>
            </template>
          </px-app-nav-group>
        </template>
      </section>

      <section class="app-nav__actions" id="actions">
        <slot id="actionsvisible" name="actions"></slot>
      </section>
    </section>

  </template>
</dom-module>

<script>
  Polymer({
    is: 'px-app-nav',
    behaviors: [Polymer.IronResizableBehavior],

    properties: {
      /**
       * Set to `true` to collapse all nav items into a dropdown. Makes the nav
       * more accessible on mobile devices.
       *
       * Use `collapseAt` instead to dynamically collapse the nav based on the
       * current window size.
       */
      collapseAll: {
        type: Boolean,
        value: false,
        observer: '_handleCollapseAllChanged',
        notify: true
      },

      /**
       * Pass a CSS media query that will collapse all nav items when it is
       * evaluated to true. For example, pass '(max-width: 450px)' to collapse
       * the nav when the window is less than 450px wide.
       *
       * This property will overwrite the `collapseAll` property. Avoid data
       * binding in to both properties at the same time.
       */
      collapseAt: {
        type: String
      },

      /**
       * The width of the collapsed menu dropdown. Use a number (e.g. `60`) which
       * will be converted to a pixel value (e.g. '60px').
       */
      collapseWidth: {
        type: Number,
        value: 320
      },

      /**
       * Set to `true` to show an open/close icon for the collapsed menu instead
       * of the selected item.
       */
      collapseWithIcon: {
        type: Boolean,
        value: false
      },

      /**
       * When `true`, the collapse dropdown is open. When `false`, it is closed
       * or does not exist.
       */
      collapseOpened: {
        type: Boolean,
        value: false,
        notify: true
      },

      /**
       * Object array of items and sub-items in the nav. Each object in the Array can specify '[path-key]', 'label', 'icon'
       * 'eventName', and 'subitems', which is another Array.
       *
       * @type {Array}
       * @default [{}]
       */
      items: {
        type: Array,
        notify: true,
        observer: '_handleNavItemsChanged'
      },

      selectedItem: {
        type: Object,
        notify: true,
        readOnly: true,
        value: null
      },

      selectedSubitem: {
        type: Object,
        notify: true,
        readOnly: true,
        value: null
      },

      selectedPath: {
        type: String,
        notify: true,
        observer: '_selectedPathChanged'
      },

      selectedSubpath: {
        type: String,
        notify: true,
        observer: '_selectedPathChanged'
      },

      fallbackPath: {
        type: String
      },

      fallbackSubpath: {
        type: String
      },

      fallbackSelected: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true
      },

      visibleItems: {
        type: Array,
        notify: true,
        readOnly: true
      },

      overflowedItems: {
        type: Array,
        notify: true,
        readOnly: true
      },

      unselectedText: {
        type: String,
        value: 'Choose item'
      },

      /**
       * True if all items are collapsed.
       */
      allCollapsed: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        computed: '_allCollapsed(overflowedItems,visibleItems)'
      },

      /**
       * True if some items are overflowed, or all items are collapsed.
       */
      anyOverflowed: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        computed: '_anyOverflowed(overflowedItems,visibleItems)'
      },

      /**
       * True if some items are overflowed, and some items are visible.
       */
      someOverflowed: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        computed: '_someOverflowed(overflowedItems,visibleItems)'
      },

      _availableWidth: {
        type: Number,
        observer: 'rebuild'
      },
    },

    statics: {
      ITEM_FONT_NAME: 'GE Inspira Sans',
      ITEM_FONT_SIZE: 15,
      ITEM_PADDING: 32, /* 16+16 */
      ITEM_ICON_WIDTH: 30,
      ITEM_ICON_PADDING: 10,
      OPEN_ICON_WIDTH: 15,
      OPEN_ICON_PADDING: 5,
      OVERFLOW_ICON_SIZE: 30,
      OVERFLOW_ICON_PADDING: 32 /*16+16*/
    },

    observers: [
      '_selectedPathChanged(fallbackPath, items)',
      '_itemVisibilityChanged(visibleItems, overflowedItems, visibleItems.*, overflowedItems.*)'
    ],

    listeners: {
      'iron-resize' : '_sizeChanged',
      'px-app-nav-item-tapped' : '_handleItemTapped'
    },

    /**
     * Gets the dropdown label text.
     *
     * There is no label text if:
     * - the menu is not collapsed
     * - the menu is collapsed and `collapseWithIcon` is true
     * - the menu is collapsed and there is no selected item
     *
     * If the menu is collapsed and an item is selected, returns the selected
     * item's label text.
     *
     * @param  {Object|undefined} selectedItem
     * @param  {Boolean} collapseWithIcon
     * @param  {Boolean} allCollapsed
     * @return {String|undefined}
     */
    _getDropdownLabel: function(selectedItem, collapseWithIcon, allCollapsed) {
      if (allCollapsed && selectedItem && typeof selectedItem === 'object' && !collapseWithIcon) {
        return selectedItem.label;
      }
      return undefined;
    },

    /**
     * Gets the dropdown icon.
     *
     * 1. If some items are overflowed but the menu is not collapsed, returns
     * the double-right-arrow icon.
     * 2. If all items are overflowed, `collapseWithIcon` is true, and the collapse
     * dropdown is closed, returns the hamburger icon.
     * 3. If all items are overflowed, `collapseWithIcon` is true, and the collapse
     * dropdown is opened, returns the X (close) icon.
     * 4. If all items are overflowed, and an item is selected, returns
     * the selected item's icon (if it exists).
     *
     * Otherwise, returns undefined.
     *
     * @param  {Object|undefined} selectedItem
     * @param  {Boolean} collapseWithIcon
     * @param  {Boolean} allCollapsed
     * @param  {Boolean} anyOverflowed
     * @param  {Boolean} collapseOpened
     * @return {String|undefined}
     */
    _getDropdownIcon: function(selectedItem, collapseWithIcon, allCollapsed, anyOverflowed, collapseOpened) {
      if (anyOverflowed && !allCollapsed) {
        return 'px:collapse';
      }
      if (allCollapsed && collapseWithIcon && !collapseOpened) {
        return 'px:hamburger';
      }
      if (allCollapsed && collapseWithIcon && collapseOpened) {
        return 'px:close';
      }
      if (allCollapsed && selectedItem && typeof selectedItem === 'object') {
        return selectedItem.icon;
      }
      return undefined;
    },

    /**
     * If the dropdown is collapsed, return the `collapseWidth` value. Otherwise,
     * return undefined.
     *
     * @return {Number|undefined}
     */
    _getDropdownWidth: function(collapseWidth, allCollapsed) {
      return allCollapsed ? collapseWidth : undefined;
    },

    /**
     * If all items are not collapsed, or if collapseWithIcon is true, hide
     * the dropdown carat.
     *
     * @return {Boolean}
     */
    _shouldHideDropdownCarat: function(allCollapsed, collapseWithIcon) {
      return !allCollapsed || collapseWithIcon;
    },

    /**
     * If the nav is collapsed, but no item is selected, show the empty state.
     */
    _isDropdownEmpty: function(selectedItem, allCollapsed, collapseWithIcon) {
      return allCollapsed && !collapseWithIcon && (!selectedItem || typeof selectedItem !== 'object');
    },

    _isItemSelected: function(item, selectedItem) {
      return item && selectedItem && item === selectedItem;
    },

    _isItemVisible: function(item) {
      if (!item || !this.visibleItems || !Array.isArray(this.visibleItems)) return false;
      return this.visibleItems.indexOf(item) !== -1;
    },

    _isItemOverflowed: function(item) {
      if (!item || !this.overflowedItems || !Array.isArray(this.overflowedItems)) return false;
      return this.overflowedItems.indexOf(item) !== -1;
    },

    _itemVisibilityChanged: function() {
      this.debounce('item-visibility-changed', function(){
        const visibleEl = Polymer.dom(this.root).querySelector('#visible');
        const overflowedEl = Polymer.dom(this.root).querySelector('#overflowed');
        if (visibleEl) visibleEl.render();
        if (overflowedEl) overflowedEl.render();
      });
    },

    _getSelectedItemLabel: function() {
       return (this.selectedItem && this.selectedItem.label) ? this.selectedItem.label : this.unselectedText;
    },

    _handleCollapseAllChanged: function(nextVal, lastVal) {
      if (this.collapseAll) {
        this.rebuild();
      }
      if (!this.collapseAll) {
        this._availableWidth = null; // Forces width to notify changes
        this._sizeChanged();
      }
    },

    _handleItemTapped: function(evt) {
      if (!evt.detail.path || !Array.isArray(evt.detail.path) || !evt.detail.path.length) return;

      if (evt.detail.path.length === 1) {
        this.set('selectedPath', evt.detail.path[0]);
        this.set('selectedSubpath', null);
      }
      if (evt.detail.path.length === 2) {
        this.set('selectedPath', evt.detail.path[0]);
        this.set('selectedSubpath', evt.detail.path[1]);
      }
    },

    _selectedPathChanged() {
      this.debounce('selected-path-changed', ()=>{
        // 1. Find the items
        let path = !this.selectedSubpath ? this.selectedPath : `${this.selectedPath}.${this.selectedSubpath}`;
        let [item, subitem] = this._findItemByPath(path);
        if (item) {
          this._setSelectedItem(item);
          this._setSelectedSubitem(subitem);
          return;
        }

        // 2. If no items found and fallback is defined, try the fallback
        if (!item && this.fallbackPath && this.fallbackPath !== this.selectedPath) {
          let path = !this.fallbackSubpath ? this.fallbackPath : `${this.fallbackPath}.${this.fallbackSubpath}`;
          let [item, subitem] = this._findItemByPath(path);
          if (item) {
            this._setSelectedItem(item);
            this._setSelectedSubitem(subitem);
            this._setFallbackSelected(true);
            return;
          }
        }

        // 3. Fallback path can't be found either
        console.log(`Could not find an item matching the path ${path}.`)
      });
    },

    _findItemByPath(pathStr) {
      let items = [null,null];
      if (typeof this._paths === 'object' && this._paths.hasOwnProperty(pathStr)) {
        items[0] = this._paths[pathStr][0];
        items[1] = this._paths[pathStr][1] || null;
      }
      return items;
    },

    created: function() {
      this._navAttached = false;
      // this._navTarget;
    },

    attached: function() {
      this._navAttached = true;
      // this._knownItems = [];
      // this._detachedItems = [];
      // var boundItemHandler = this._handleItemsDistributed.bind(this);
      // this._itemObserver = Polymer.dom(this.$.new).observeNodes(boundItemHandler);
    },

    detached: function() {
      this._navAttached = false;
      // this._knownItems = null;
      // this._detachedItems = null;
      // Polymer.dom(this.$.new).unobserveNodes(this._itemObserver);
    },

    _sizeChanged: function() {
      if (this.collapseAll) return;

      const debouncer = 'measure-available-width';
      if (typeof this._availableWidth !== 'number') {
        this._getAvailableWidth();
        return;
      }
      if (this.isDebouncerActive(debouncer)) {
        this.cancelDebouncer(debouncer);
      }
      this.debounce(debouncer, this._getAvailableWidth.bind(this), 100);
    },

    _getAvailableWidth: function() {
      window.requestAnimationFrame(() => {
        const containerEl = this.$.container;
        const actionsEl = this.$.actions;
        if (!containerEl || !actionsEl) return;
        const containerWidth = containerEl.getBoundingClientRect().width;
        const actionsWidth = actionsEl.getBoundingClientRect().width;
        const width = containerWidth - actionsWidth;
        if (this._availableWidth !== width) this.set('_availableWidth', width);
      });
    },

    _handleNavItemsChanged(items) {
      const paths = this._paths = this._getItemPaths(items);
      this.rebuild();
    },

    _getItemPaths(items, parent, paths={}) {
      for (let item of items) {
        let pathKey = parent ? `${parent.path}.${item.path}` : item.path;
        if (paths[pathKey]) {
          console.log(`ERR: Path ${pathKey} is not unique. All paths must be unique.`);
        }
        else if (parent) {
          paths[pathKey] = [parent, item];
        }
        else {
          paths[pathKey] = [item];
        }

        if (item.subitems) {
          this._getItemPaths(item.subitems, item, paths);
        }
      }

      return paths;
    },

    /**
     * Rebuilds the nav to reflect its `type` and `collapseAll` settings.
     */
    rebuild: function() {
      if (!this.items || !Array.isArray(this.items) || this._pendingRender || (!this.collapseAll && typeof this._availableWidth !== 'number')) return;

      if (this.collapseAll || this._availableWidth === 0) {
        this._setVisibleItems([]);
        this._setOverflowedItems(this.items.slice(0));
        return;
      }

      const measurements = this._measureItems(this.items);
      const {visible, overflowed} = this._fitItems(this.items, this._availableWidth, measurements);
      this._setVisibleItems(visible);
      this._setOverflowedItems(overflowed);
      this.notifyPath('visibleItems.*');
      this.notifyPath('overflowedItems.*');
    },

    _fitItems: function(items, width, measurements) {
      let available = width;

      // If the first item is larger than the available, collapse all
      if (available < measurements[0]) {
        return { visible: [], overflowed: items.slice(0) };
      }

      // Try to fit items in the available space
      let i = 0;
      let len = items.length;

      while (i<len && available>0) {
        if (measurements[i] > available) {
          break;
        }
        available -= measurements[i];
        i++;
      }

      // If any overflow, ensure the overflow icon can fit
      let overflowSize = this.statics.OVERFLOW_ICON_SIZE + this.statics.OVERFLOW_ICON_PADDING;
      if (i !== len && available < overflowSize) {
        available -= overflowSize;
        while (i>0 && available<0) {
          available += measurements[i];
          i--;
        }
      }
      return { visible: items.slice(0,i), overflowed: items.slice(i) };
    },

    _measureItems: function(items) {
      const boundMeasureFn = this._measureItem.bind(this);
      return items.map(boundMeasureFn);
    },

    _measureItem: function(item) {
      const textLength = this._measureText(item.label, this.statics.ITEM_FONT_NAME, this.statics.ITEM_FONT_SIZE + 'px');
      if (!textLength) return;
      let totalLength = textLength; /* start with text size */
      totalLength += this.statics.ITEM_PADDING; /* add left pad + right pad */
      if (item.icon && item.icon.length) totalLength += (this.statics.ITEM_ICON_WIDTH + this.statics.ITEM_ICON_PADDING); /* add icon size + icon right pad */
      if (item.subitems && item.subitems.length) totalLength += (this.statics.OPEN_ICON_WIDTH + this.statics.OPEN_ICON_PADDING); /* add dropdown icon size + dropdown icon left pad */
      return totalLength;
    },

    _measureText: function(text, fontName, fontSize) {
      var cv = this._get2dMeasureCanvas(fontName, fontSize);
      var size = cv.measureText(text).width;
      return isNaN(size) ? undefined : Math.round(size);
    },

    _get2dMeasureCanvas: function(fontName, fontSize) {
      this.__measureCanvasCache = this.__measureCanvasCache || {};
      var fontInfo = fontSize + ' ' + fontName;
      if (this.__measureCanvasCache[fontInfo]) return this.__measureCanvasCache[fontInfo];
      var cv = document.createElement('canvas');
      cv.height = 999;
      cv.width = 999;
      var ctx = cv.getContext('2d');
      ctx.font = fontInfo;
      return (this.__measureCanvasCache[fontInfo] = ctx);
    },

    /**
     * Finds and returns an item that passes the test `item[prop] === val` or
     * returns undefined.
     *
     * @param {Array} items - An array of `HTMLElement` to search
     * @param {String|Number} val
     * @param {String} prop - The property to check
     * @returns {HTMLElement|undefined}
     *
     */
    _findItem(items, val, prop) {
      var found;
      var i = 0;
      var len = items.length;

      for (; i<len; i++) {
        if (typeof items[i][prop] !== 'undefined' && items[i][prop] === val) {
          found = items[i];
          break;
        }
      }

      return found;
    },

    /**
     * Helps check if items generated from data have subitems.
     */
    _hasSubitems(item) {
      return item && Array.isArray(item.subitems) && item.subitems.length;
    },

    _ifSelectedOverflowed(selectedItem, overflowedItems) {
      if (!selectedItem || !overflowedItems || !Array.isArray(overflowedItems) || !overflowedItems.length) return false;
      return overflowedItems.indexOf(selectedItem) !== -1;
    },

    /**
     * Helps check if items generated from data have subitems.
     */
    _hasNoSubitems(item) {
      return !item.hasOwnProperty('subitems');
    },

    _anyOverflowed(overflowed, visible) {
      return Array.isArray(overflowed) && overflowed.length > 0;
    },

    _allCollapsed(overflowed, visible) {
      return Array.isArray(overflowed) && overflowed.length > 0 && Array.isArray(visible) && visible.length === 0;
    },

    _someOverflowed(overflowed, visible) {
      return Array.isArray(overflowed) && overflowed.length > 0 && Array.isArray(visible) && visible.length > 0;
    }
  });
</script>
