<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-dropdown/iron-dropdown.html" />
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html" />

<link rel="import" href="px-app-nav-group.html" />
<link rel="import" href="px-app-nav-subgroup.html" />
<link rel="import" href="px-app-nav-item.html" />

<!--
px-app-nav is a navigation component that allows the user to browse app pages
and content. It is fully responsive and comes in three visual styles:

#### 1. Horizontal navigation

A persistent, horizontal navigation that is fixed to the top of the browser
window. (This is the default style.) The nav items will be displayed in a row at
the top of the screen. If the window is too narrow to display all the items,
any overflowed items will be placed into an overflow dropdown. If only one nav
item fits in the window, the nav will collapse (see #2).

```
<px-app-nav
    items='[
      { "label" : "Home",   "path" : "home",   "icon" : "px:home" },
      { "label" : "Alerts", "path" : "alerts", "icon" : "px:alert" },
      { "label" : "Assets", "path" : "assets", "icon" : "px:asset", subitems: [
        { "label" : "Asset #1", "path" : "a1" },
        { "label" : "Asset #2", "path" : "a2" }
      ] }
    ]'
    selected-item="assets"
    selected-item="a1">
</px-app-nav>
```

#### 2. Collapsed navigation

A persistent, collapsed navigation that is fixed to the top of the browser.
The nav items will be displayed in a dropdown menu that can be opened and closed.
The selected item (if any) will be displayed at the top of the dropdown, and is
always visible. This style can be turned on by default with the `collapseAll`
attribute. It can turned on dynamically when the window is shrunk below a desired
size with the `collapseAt` attribute.

```
<px-app-nav
    items='[
      { "label" : "Home",   "path" : "home",   "icon" : "px:home" },
      { "label" : "Alerts", "path" : "alerts", "icon" : "px:alert" },
      { "label" : "Assets", "path" : "assets", "icon" : "px:asset", subitems: [
        { "label" : "Asset #1", "path" : "a1" },
        { "label" : "Asset #2", "path" : "a2" }
      ] }
    ]'
    selected-item="home"
    collapse-all>
</px-app-nav>
```

#### 3. Vertical navigation

An animated navigation that is fixed to the left or right side of the browser.
When the user is not interacting with the nav, only the nav item icons will
be visible. When the user hovers over the nav, it will animate open and reveal
item labels. (Development of this style is still in progress.)

```
<px-app-nav
    items='[
      { "label" : "Home",   "path" : "home",   "icon" : "px:home" },
      { "label" : "Alerts", "path" : "alerts", "icon" : "px:alert" },
      { "label" : "Assets", "path" : "assets", "icon" : "px:asset", subitems: [
        { "label" : "Asset #1", "path" : "a1" },
        { "label" : "Asset #2", "path" : "a2" }
      ] }
    ]'
    selected-item="alerts"
    vertical>
</px-app-nav>
```

#### Styling

The following custom properties are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--px-app-nav-xxx` | Xxxx xxx xxxxx xxxxxx | `$xxxXX`

@element px-app-nav
@blurb A navigation component that allows the user to browse app pages and content
@homepage index.html
@demo index.html
-->

<link rel="import" href="css/px-app-nav-styles.html">

<dom-module id="px-app-nav">
  <template>
    <style include="px-app-nav-styles"></style>

    <section class="app-nav" id="container">
      <section class="app-nav__items" id="items">
        <!-- First item stamp: visible items -->
        <template is="dom-repeat" items="{{items}}" filter="_isItemVisible" id="visible">
          <!-- Stamp groups, which hold subitems -->
          <template is="dom-if" if="{{_hasSubitems(item)}}">
            <px-app-nav-group label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}" selected$="{{_isItemSelected(item, selectedItem)}}">
              <template is="dom-repeat" items="{{item.subitems}}" as="subitem">
                <px-app-nav-item label="{{subitem.label}}" path="{{subitem.path}}" selected$="{{_isItemSelected(subitem, selectedSubitem)}}" subitem></px-app-nav-item>
              </template>
            </px-app-nav-group>
          </template>

          <!-- Stamp plain old items, which hold subitems -->
          <template is="dom-if" if="{{_hasNoSubitems(item)}}">
            <px-app-nav-item label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}" selected$="{{_isItemSelected(item, selectedItem)}}">
            </px-app-nav-item>
          </template>
        </template>

        <!-- STATE: Items overflowed or collapsed -->
        <template is="dom-if" if="{{_anyOverflowed(overflowedItems, visibleItems)}}">
          <px-app-nav-group
              superlist
              fixed-width="[[_getDropdownWidth(collapseDropdownWidth, allCollapsed)]]"
              id="overflowedGroup"
              label="{{_getDropdownLabel(selectedItem, collapseWithIcon, allCollapsed)}}"
              icon="{{_getDropdownIcon(selectedItem, collapseWithIcon, allCollapsed, anyOverflowed, collapseOpened)}}"
              selected$="{{_ifSelectedOverflowed(selectedItem, overflowedItems)}}"
              hide-dropdown-icon="{{_shouldHideDropdownCarat(allCollapsed, collapseWithIcon)}}"
              no-highlight="{{allCollapsed}}"
              empty="{{_isDropdownEmpty(selectedItem, allCollapsed, collapseWithIcon)}}"
              opened="{{collapseOpened}}">
            <!-- Second item stamp: overflowed/collapsed items -->
            <template is="dom-repeat" items="{{items}}" filter="_isItemOverflowed" id="overflowed">
              <!-- Stamp groups, which hold subitems -->
              <template is="dom-if" if="{{_hasSubitems(item)}}">
                <px-app-nav-subgroup label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}" selected$="{{_isItemSelected(item, selectedItem)}}" overflowed$="{{someOverflowed}}" collapsed$="{{allCollapsed}}">
                  <template is="dom-repeat" items="{{item.subitems}}" as="subitem">
                    <px-app-nav-item label="{{subitem.label}}" path="{{subitem.path}}" selected$="{{_isItemSelected(subitem, selectedSubitem)}}" parent-selected$="{{_isItemSelected(item, selectedItem)}}" subitem collapsed$="{{allCollapsed}}"></px-app-nav-item>
                  </template>
                </px-app-nav-subgroup>
              </template>

              <!-- Stamp plain old items, which hold subitems -->
              <template is="dom-if" if="{{_hasNoSubitems(item)}}">
                <px-app-nav-item label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}" selected$="{{_isItemSelected(item, selectedItem)}}" overflowed$="{{someOverflowed}}" collapsed$="{{allCollapsed}}">
                </px-app-nav-item>
              </template>
            </template>
          </px-app-nav-group>
        </template>
      </section>

      <section class="app-nav__actions" id="actions">
        <slot id="actionsvisible" name="actions"></slot>
      </section>
    </section>

  </template>
</dom-module>

<script>
  Polymer({
    is: 'px-app-nav',
    behaviors: [Polymer.IronResizableBehavior],

    properties: {
      /**
       * An array of objects that will be used to build the nav. Top-level items
       * can have one level of subitems beneath them, turning the parent item
       * into a dropdown group.
       *
       * All items and subitems should have at least the following properties:
       *
       * - {String} path - A unique string that identifies the item. Should only
       * contain alphanumeric characters matching A-Z, a-z, or 0-9. Avoid using
       * special characters that must be encoded or decoded in URLs. The path
       * must not contain any dots (`.`). Examples: 'home' or 'alerts'
       * - {String} label - A short, human-readable text label for the item
       *
       * The following optional properties can be used for top-level items only:
       *
       * - {String} icon - The name of a valid iron-icon that will be placed
       * next to the text label for the item. Use a valid icon from px-icon-set
       * or define your own using the iron-iconset or iron-iconset-svg elements.
       * - {Array} subitems - An array of subitem objects that will placed in a
       * dropdown under the top-level item. Each subitem must have a `path`
       * and `label` defined. If an `icon` or `subitems` property is defined
       * on a subitem, those properties will be ignored.
       *
       * Note that top-level items with subitems cannot be directly selected
       * by the user. They will only be selected when one of their subitems
       * is tapped.
       *
       * The following is an example of a list of valid nav items:
       *
       *     [
       *       { "label" : "Home",   "path" : "home",   "icon" : "px:home" },
       *       { "label" : "Alerts", "path" : "alerts", "icon" : "px:alert" },
       *       { "label" : "Assets", "path" : "assets", "icon" : "px:asset", subitems: [
       *         { "label" : "Asset #1", "path" : "a1" },
       *         { "label" : "Asset #2", "path" : "a2" }
       *       ] }
       *     ]
       *
       */
      items: {
        type: Array,
        notify: true,
        observer: '_handleNavItemsChanged'
      },

      /**
       * Set to `true` to collapse all nav items into a dropdown. Makes the nav
       * more accessible on mobile devices.
       *
       * Use `collapseAt` instead to dynamically collapse the nav based on the
       * current window size.
       */
      collapseAll: {
        type: Boolean,
        value: false,
        observer: '_handleCollapseAllChanged',
        notify: true
      },

      /**
       * The width below which the nav will automatically collapse. Use a number
       * (e.g. `450`) which will be converted to a pixel value (e.g. '450px').
       *
       * This property will overwrite the `collapseAll` property. Avoid data
       * binding in to both properties at the same time.
       */
      collapseAt: {
        type: Number,
        observer: 'rebuild'
      },

      /**
       * The width of the collapsed menu dropdown. Use a number (e.g. `60`) which
       * will be converted to a pixel value (e.g. '60px').
       */
      collapseDropdownWidth: {
        type: Number,
        value: 320
      },

      /**
       * Set to `true` to show an open/close icon for the collapsed menu instead
       * of the selected item.
       */
      collapseWithIcon: {
        type: Boolean,
        value: false
      },

      /**
       * When `true`, the collapse dropdown is open. When `false`, it is closed
       * or does not exist.
       */
      collapseOpened: {
        type: Boolean,
        value: false,
        notify: true
      },

      /**
       * A reference to the currently selected item's object. This is a read-only
       * value you can bind to and use to update your app's state, e.g. to
       * change the current page to some value stored in the selected item's
       * object. To change the selected item, use the `selectedPath` attribute.
       *
       * This is a direct reference to the item that was passed into the `items`
       * list, and can be compared with its `items` entry using reference equality.
       *
       * Note that the `selectedItem` may initially notify its value as `null`
       * if no `selectedPath` is initially set, or if the `selectedPath` is
       * set late.
       */
      selectedItem: {
        type: Object,
        notify: true,
        readOnly: true,
        value: null
      },

      /**
       * A reference to the currently selected subitem's object. This is a read-only
       * value you can bind to and use to update your app's state, e.g. to
       * change the current page to some value stored in the selected subitem's
       * object. To change the selected subitem, use the `selectedSubpath` attribute.
       *
       * This is a direct reference to the subitem that was passed into the `items`
       * list, and can be compared with its `items` entry using reference equality.
       *
       * Note that the `selectedSubitem` may initially notify its value as `null`
       * if no `selectedSubath` is initially set, or if the `selectedSubpath` is
       * set late.
       */
      selectedSubitem: {
        type: Object,
        notify: true,
        readOnly: true,
        value: null
      },

      /**
       * The path of the currently selected item. Set this attribute to select
       * an item. Listen for updates to this attribute to be notified when
       * the user selects a new item.
       */
      selectedPath: {
        type: String,
        notify: true,
        observer: '_selectedPathChanged'
      },

      /**
       * The path of the currently selected subitem. Set this attribute to select
       * a subitem. Listen for updates to this attribute to be notified when
       * the user selects a new subitem.
       */
      selectedSubpath: {
        type: String,
        notify: true,
        observer: '_selectedPathChanged'
      },

      /**
       * The path to an item that will be visually selected and set as the
       * `selectedItem` if no valid `selectedPath` is provided.
       *
       * Note that when the fallback path is used to select an item, the `selectedPath`
       * attribute will not be updated. This ensures that data binding the
       * `selectedPath` to your app router won't spam the window location
       * with values when the page first loads. To initially select an item,
       * use `selectedPath` instead.
       */
      fallbackPath: {
        type: String
      },

      /**
       * The path to a subitem that will be visually selected and set as the
       * `selectedSubitem` if no valid `selectedPath` is provided.
       *
       * If a valid `selectedPath` is provided and no valid `selectedSubpath` is
       * provided, the fallbackSubpath will not be used.
       *
       * Note that when the fallback subpath is used to select a subitem, the `selectedSubpath`
       * attribute will not be updated. This ensures that data binding the
       * `selectedSubpath` to your app router won't spam the window location
       * with values when the page first loads. To initially select an item,
       * use `selectedSubpath` instead.
       */
      fallbackSubpath: {
        type: String
      },

      /**
       * True if the fallbackPath and/or fallbackSubpath were used to initially
       * select an item and/or subitem.
       */
      fallbackSelected: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true
      },

      /**
       * An array of items that are currently visible — they fit in the menu
       * and are not overflowed or collapse.
       */
      visibleItems: {
        type: Array,
        notify: true,
        readOnly: true
      },

      /**
       * An array of items that are currently hidden in the overflow dropdown
       * or in the collapsed dropdown.
       */
      overflowedItems: {
        type: Array,
        notify: true,
        readOnly: true
      },

      /**
       * True if all items are collapsed.
       */
      allCollapsed: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        computed: '_allCollapsed(overflowedItems,visibleItems)'
      },

      /**
       * True if some items are overflowed, or all items are collapsed.
       */
      anyOverflowed: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        computed: '_anyOverflowed(overflowedItems,visibleItems)'
      },

      /**
       * True if some items are overflowed, and some items are visible.
       */
      someOverflowed: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        computed: '_someOverflowed(overflowedItems,visibleItems)'
      },

      _availableWidth: {
        type: Number,
        observer: 'rebuild'
      }
    },

    statics: {
      ITEM_FONT_NAME: 'GE Inspira Sans',
      ITEM_FONT_SIZE: 15,
      ITEM_PADDING: 32, /* 16+16 */
      ITEM_ICON_WIDTH: 30,
      ITEM_ICON_PADDING: 10,
      OPEN_ICON_WIDTH: 15,
      OPEN_ICON_PADDING: 5,
      OVERFLOW_ICON_SIZE: 30,
      OVERFLOW_ICON_PADDING: 32 /*16+16*/
    },

    observers: [
      '_selectedPathChanged(fallbackPath, items)',
      '_itemVisibilityChanged(visibleItems, overflowedItems, visibleItems.*, overflowedItems.*)'
    ],

    listeners: {
      'iron-resize' : '_sizeChanged',
      'px-app-nav-item-tapped' : '_handleItemTapped'
    },

    /**
     * Gets the dropdown label text.
     *
     * There is no label text if:
     * - the menu is not collapsed
     * - the menu is collapsed and `collapseWithIcon` is true
     * - the menu is collapsed and there is no selected item
     *
     * If the menu is collapsed and an item is selected, returns the selected
     * item's label text.
     *
     * Otherwise, returns null.
     *
     * @param  {Object|undefined} selectedItem
     * @param  {Boolean} collapseWithIcon
     * @param  {Boolean} allCollapsed
     * @return {String|null}
     */
    _getDropdownLabel: function(selectedItem, collapseWithIcon, allCollapsed) {
      if (allCollapsed && selectedItem && typeof selectedItem === 'object' && !collapseWithIcon) {
        return selectedItem.label;
      }
      return null;
    },

    /**
     * Gets the dropdown icon.
     *
     * 1. If some items are overflowed but the menu is not collapsed, returns
     * the double-right-arrow icon.
     * 2. If all items are overflowed, `collapseWithIcon` is true, and the collapse
     * dropdown is closed, returns the hamburger icon.
     * 3. If all items are overflowed, `collapseWithIcon` is true, and the collapse
     * dropdown is opened, returns the X (close) icon.
     * 4. If all items are overflowed, and an item is selected, returns
     * the selected item's icon (if it exists).
     *
     * Otherwise, returns null.
     *
     * @param  {Object|undefined} selectedItem
     * @param  {Boolean} collapseWithIcon
     * @param  {Boolean} allCollapsed
     * @param  {Boolean} anyOverflowed
     * @param  {Boolean} collapseOpened
     * @return {String|null}
     */
    _getDropdownIcon: function(selectedItem, collapseWithIcon, allCollapsed, anyOverflowed, collapseOpened) {
      if (anyOverflowed && !allCollapsed) {
        return 'px:collapse';
      }
      if (allCollapsed && collapseWithIcon && !collapseOpened) {
        return 'px:hamburger';
      }
      if (allCollapsed && collapseWithIcon && collapseOpened) {
        return 'px:close';
      }
      if (allCollapsed && selectedItem && typeof selectedItem === 'object') {
        return selectedItem.icon;
      }
      return null;
    },

    /**
     * If the dropdown is collapsed, return the `collapseDropdownWidth` value. Otherwise,
     * return undefined.
     *
     * @return {Number|undefined}
     */
    _getDropdownWidth: function(collapseDropdownWidth, allCollapsed) {
      return allCollapsed ? collapseDropdownWidth : undefined;
    },

    /**
     * If all items are not collapsed, or if collapseWithIcon is true, hide
     * the dropdown carat.
     *
     * @return {Boolean}
     */
    _shouldHideDropdownCarat: function(allCollapsed, collapseWithIcon) {
      return !allCollapsed || collapseWithIcon;
    },

    /**
     * If the nav is collapsed, but no item is selected, show the empty state.
     */
    _isDropdownEmpty: function(selectedItem, allCollapsed, collapseWithIcon) {
      return allCollapsed && !collapseWithIcon && (!selectedItem || typeof selectedItem !== 'object');
    },

    _isItemSelected: function(item, selectedItem) {
      return item && selectedItem && item === selectedItem;
    },

    _isItemVisible: function(item) {
      if (!item || !this.visibleItems || !Array.isArray(this.visibleItems)) return false;
      return this.visibleItems.indexOf(item) !== -1;
    },

    _isItemOverflowed: function(item) {
      if (!item || !this.overflowedItems || !Array.isArray(this.overflowedItems)) return false;
      return this.overflowedItems.indexOf(item) !== -1;
    },

    _itemVisibilityChanged: function() {
      this.debounce('item-visibility-changed', function(){
        const visibleEl = Polymer.dom(this.root).querySelector('#visible');
        const overflowedEl = Polymer.dom(this.root).querySelector('#overflowed');
        if (visibleEl) visibleEl.render();
        if (overflowedEl) overflowedEl.render();
      });
    },

    _getSelectedItemLabel: function() {
       return (this.selectedItem && this.selectedItem.label) ? this.selectedItem.label : this.unselectedText;
    },

    _handleCollapseAllChanged: function(nextVal, lastVal) {
      if (this.collapseAll) {
        this.rebuild();
      }
      if (!this.collapseAll) {
        this._availableWidth = null; // Forces width to notify changes
        this._sizeChanged();
      }
    },

    _handleItemTapped: function(evt) {
      if (!evt.detail.path || !Array.isArray(evt.detail.path) || !evt.detail.path.length) return;

      if (evt.detail.path.length === 1) {
        this.set('selectedPath', evt.detail.path[0]);
        this.set('selectedSubpath', null);
      }
      if (evt.detail.path.length === 2) {
        this.set('selectedPath', evt.detail.path[0]);
        this.set('selectedSubpath', evt.detail.path[1]);
      }
    },

    _selectedPathChanged() {
      this.debounce('selected-path-changed', ()=>{
        // 1. Find the items
        let path = !this.selectedSubpath ? this.selectedPath : `${this.selectedPath}.${this.selectedSubpath}`;
        let [item, subitem] = this._findItemByPath(path);
        if (item) {
          this._setSelectedItem(item);
          this._setSelectedSubitem(subitem);
          return;
        }

        // 2. If no items found and fallback is defined, try the fallback
        if (!item && this.fallbackPath && this.fallbackPath !== this.selectedPath) {
          let path = !this.fallbackSubpath ? this.fallbackPath : `${this.fallbackPath}.${this.fallbackSubpath}`;
          let [item, subitem] = this._findItemByPath(path);
          if (item) {
            this._setSelectedItem(item);
            this._setSelectedSubitem(subitem);
            this._setFallbackSelected(true);
            return;
          }
        }

        // 3. Fallback path can't be found either
        console.log(`Could not find an item matching the path ${path}.`)
      });
    },

    _findItemByPath(pathStr) {
      let items = [null,null];
      if (typeof this._paths === 'object' && this._paths.hasOwnProperty(pathStr)) {
        items[0] = this._paths[pathStr][0];
        items[1] = this._paths[pathStr][1] || null;
      }
      return items;
    },

    created: function() {
      this._navAttached = false;
      // this._navTarget;
    },

    attached: function() {
      this._navAttached = true;
      // this._knownItems = [];
      // this._detachedItems = [];
      // var boundItemHandler = this._handleItemsDistributed.bind(this);
      // this._itemObserver = Polymer.dom(this.$.new).observeNodes(boundItemHandler);
    },

    detached: function() {
      this._navAttached = false;
      // this._knownItems = null;
      // this._detachedItems = null;
      // Polymer.dom(this.$.new).unobserveNodes(this._itemObserver);
    },

    _sizeChanged: function() {
      if (this.collapseAll) return;

      const debouncer = 'measure-available-width';
      if (typeof this._availableWidth !== 'number') {
        this._getAvailableWidth();
        return;
      }
      if (this.isDebouncerActive(debouncer)) {
        this.cancelDebouncer(debouncer);
      }
      this.debounce(debouncer, this._getAvailableWidth.bind(this), 100);
    },

    _getAvailableWidth: function() {
      window.requestAnimationFrame(() => {
        const containerEl = this.$.container;
        const actionsEl = this.$.actions;
        if (!containerEl || !actionsEl) return;
        const containerWidth = containerEl.getBoundingClientRect().width;
        const actionsWidth = actionsEl.getBoundingClientRect().width;
        const width = containerWidth - actionsWidth;
        if (this._availableWidth !== width) this.set('_availableWidth', width);
      });
    },

    _handleNavItemsChanged(items) {
      if (!items || !Array.isArray(items)) return;
      const paths = this._paths = this._getItemPaths(items);
      this.rebuild();
    },

    _getItemPaths(items, parent, paths={}) {
      for (let item of items) {
        let pathKey = parent ? `${parent.path}.${item.path}` : item.path;
        if (paths[pathKey]) {
          console.log(`ERR: Path ${pathKey} is not unique. All paths must be unique.`);
        }
        else if (parent) {
          paths[pathKey] = [parent, item];
        }
        else {
          paths[pathKey] = [item];
        }

        if (item.subitems) {
          this._getItemPaths(item.subitems, item, paths);
        }
      }

      return paths;
    },

    /**
     * Rebuilds the nav to reflect its `type` and `collapseAll` settings.
     */
    rebuild: function() {
      if (!this.items || !Array.isArray(this.items) || this._pendingRender || (!this.collapseAll && typeof this._availableWidth !== 'number')) return;

      if (this.collapseAll || this._availableWidth === 0 || (typeof this.collapseAt === 'number' && this._availableWidth <= this.collapseAt)) {
        this._setVisibleItems([]);
        this._setOverflowedItems(this.items.slice(0));
        return;
      }

      const measurements = this._measureItems(this.items);
      const {visible, overflowed} = this._fitItems(this.items, this._availableWidth, measurements);

      // If only one item can fit, switch to collapsed mode
      if (visible.length === 1) {
        this._setVisibleItems([]);
        this._setOverflowedItems(this.items.slice(0));
        return;
      }

      this._setVisibleItems(visible);
      this._setOverflowedItems(overflowed);
      this.notifyPath('visibleItems.*');
      this.notifyPath('overflowedItems.*');
    },

    _fitItems: function(items, width, measurements) {
      let available = width;

      // If the first item is larger than the available, collapse all
      if (available < measurements[0]) {
        return { visible: [], overflowed: items.slice(0) };
      }

      // Try to fit items in the available space
      let i = 0;
      let len = items.length;

      while (i<len && available>0) {
        if (measurements[i] > available) {
          break;
        }
        available -= measurements[i];
        i++;
      }

      // If any overflow, ensure the overflow icon can fit
      let overflowSize = this.statics.OVERFLOW_ICON_SIZE + this.statics.OVERFLOW_ICON_PADDING;
      if (i !== len && available < overflowSize) {
        available -= overflowSize;
        while (i>0 && available<0) {
          available += measurements[i];
          i--;
        }
      }
      return { visible: items.slice(0,i), overflowed: items.slice(i) };
    },

    _measureItems: function(items) {
      const boundMeasureFn = this._measureItem.bind(this);
      return items.map(boundMeasureFn);
    },

    _measureItem: function(item) {
      const textLength = this._measureText(item.label, this.statics.ITEM_FONT_NAME, this.statics.ITEM_FONT_SIZE + 'px');
      if (!textLength) return;
      let totalLength = textLength; /* start with text size */
      totalLength += this.statics.ITEM_PADDING; /* add left pad + right pad */
      if (item.icon && item.icon.length) totalLength += (this.statics.ITEM_ICON_WIDTH + this.statics.ITEM_ICON_PADDING); /* add icon size + icon right pad */
      if (item.subitems && item.subitems.length) totalLength += (this.statics.OPEN_ICON_WIDTH + this.statics.OPEN_ICON_PADDING); /* add dropdown icon size + dropdown icon left pad */
      return totalLength;
    },

    _measureText: function(text, fontName, fontSize) {
      var cv = this._get2dMeasureCanvas(fontName, fontSize);
      var size = cv.measureText(text).width;
      return isNaN(size) ? undefined : Math.round(size);
    },

    _get2dMeasureCanvas: function(fontName, fontSize) {
      this.__measureCanvasCache = this.__measureCanvasCache || {};
      var fontInfo = fontSize + ' ' + fontName;
      if (this.__measureCanvasCache[fontInfo]) return this.__measureCanvasCache[fontInfo];
      var cv = document.createElement('canvas');
      cv.height = 999;
      cv.width = 999;
      var ctx = cv.getContext('2d');
      ctx.font = fontInfo;
      return (this.__measureCanvasCache[fontInfo] = ctx);
    },

    /**
     * Finds and returns an item that passes the test `item[prop] === val` or
     * returns undefined.
     *
     * @param {Array} items - An array of `HTMLElement` to search
     * @param {String|Number} val
     * @param {String} prop - The property to check
     * @returns {HTMLElement|undefined}
     *
     */
    _findItem(items, val, prop) {
      var found;
      var i = 0;
      var len = items.length;

      for (; i<len; i++) {
        if (typeof items[i][prop] !== 'undefined' && items[i][prop] === val) {
          found = items[i];
          break;
        }
      }

      return found;
    },

    /**
     * Helps check if items generated from data have subitems.
     */
    _hasSubitems(item) {
      return item && Array.isArray(item.subitems) && item.subitems.length;
    },

    _ifSelectedOverflowed(selectedItem, overflowedItems) {
      if (!selectedItem || !overflowedItems || !Array.isArray(overflowedItems) || !overflowedItems.length) return false;
      return overflowedItems.indexOf(selectedItem) !== -1;
    },

    /**
     * Helps check if items generated from data have subitems.
     */
    _hasNoSubitems(item) {
      return !item.hasOwnProperty('subitems');
    },

    _anyOverflowed(overflowed, visible) {
      return Array.isArray(overflowed) && overflowed.length > 0;
    },

    _allCollapsed(overflowed, visible) {
      return Array.isArray(overflowed) && overflowed.length > 0 && Array.isArray(visible) && visible.length === 0;
    },

    _someOverflowed(overflowed, visible) {
      return Array.isArray(overflowed) && overflowed.length > 0 && Array.isArray(visible) && visible.length > 0;
    }
  });
</script>
