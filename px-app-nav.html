<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<link rel="import" href="../polymer/polymer.html">
<!-- <link rel="import" href="../px-tooltip/px-tooltip.html"> -->
<!-- <link rel="import" href="../neon-animation/neon-animation.html"> -->

<link rel="import" href="../px-polymer-font-awesome/px-polymer-font-awesome.html" />
<link rel="import" href="../app-layout/app-toolbar/app-toolbar.html" />
<link rel="import" href="../app-layout/app-header/app-header.html" />
<link rel="import" href="../iron-dropdown/iron-dropdown.html" />
<link rel="import" href="../iron-selector/iron-selector.html" />
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html" />

<link rel="import" href="px-app-nav-horizontal.html" />
<link rel="import" href="px-app-nav-collapsed.html" />
<link rel="import" href="px-app-nav-list.html" />
<link rel="import" href="px-app-nav-group.html" />

<link rel="import" href="px-app-nav-item.html" />
<link rel="import" href="px-app-nav-subitem.html" />

<!--

#### Usage

    <px-app-nav
        nav-items='[{"path": "", "icon": "fa-exclamation-triangle", "label":"//alerts","subitems": [{"label": "Sub Category 1"}, {"label": "Sub Category 2"}]},{"path": "tab2", "icon": "fa-briefcase", "label": "Cases"}]'
            <any-arbitrary-content></any-arbitrary-content>
            <div class="auth">
                <any-auth-control></any-auth-control>
            </div>
    </px-app-nav>

#### Styling
The following custom properties are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--px-app-nav-background-color` | Background color for the app navigation component | `$gray10`
`--px-app-nav-link-text-color` | Text color for the nav items | `$white`
`--px-app-nav-link-hover-color` | Background color for a nav item when a user hovers over one | `$gray8`
`--px-app-nav-link-selected-active-color` | Background color for a nav item when a user clicks on one | `$select-blue-hover`
`--px-app-nav-link-selected-color` | Background color for the selected nav item | `$select-blue-pressed`
`--px-app-nav-hamburger-button-color` | Fill color for the hamburger menu icon | `$white`

@element px-app-nav
@blurb Nav bar / drawer for applications.
@homepage index.html
@demo index.html
-->

<link rel="import" href="css/px-app-nav-styles.html">

<dom-module id="px-app-nav">
  <template>
    <style include="px-app-nav-styles">
      #root {
        display: none;
      }
      .app-nav-toolbar-collapsed {
        display: none;
      }
      .app-nav--collapsed .app-nav-toolbar-collapsed {
        display: inherit;
      }
      .app-nav-visible {
        display: flex;
      }
      .app-nav-collapsed {
        display: none;
      }
      .app-nav-toolbar {
        background-color: rgb(223, 230, 234);
        box-shadow: rgba(0, 0, 0, 0.298039) 0px 1px 3px;
        height: 60px;
        padding-left: 0;
        padding-right: 0;
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        max-width: 100%;
      }
      .app-nav-items {
        height: 60px;
        flex: 1;
        display: flex;
        max-width: 100%;
      }
    </style>
    <section class$="{{_getNavClasses(type, collapseAll)}}">
      <app-header fixed>
        <app-toolbar class="app-nav-toolbar" id="toolbar">
          <section class="app-nav-items" id="items">
            <div class="app-nav-visible" id="visible"></div>
            <div class="app-nav-collapsed" id="collapsed"></div>
            <div class$="app-nav-items__collapse-button {{_getCollapsedButtonClasses(collapsedItems)}}">
              <iron-icon icon="fa:fa-angle-double-right"></iron-icon>
            </div>
          </section>
        </app-toolbar>
      </app-header>
    </section>

  </template>
</dom-module>

<script>
  Polymer({
    is: 'px-app-nav',
    behaviors: [Polymer.IronResizableBehavior],

    properties: {
      initialCount: {
        type: Number,
        value: 3
      },

      /**
       * Set to 'horizontal' to display nav across the top of the screen, or set
       * to 'vertical' to display navigation along the side of the screen.
       */
      type: {
        type: String,
        value: 'horizontal',
        observer: 'rebuild'
      },

      /**
       * Set to `true` to collapse all nav items (including top-level items)
       * into a dropdown and only show the active item in the nav.
       *
       * Only works if the the nav `type` is horizontal.
       */
      collapseAll: {
        type: Boolean,
        value: false,
        observer: 'rebuild'
      },

      /**
       * Object array of items and sub-items in the nav. Each object in the Array can specify '[path-key]', 'label', 'icon'
       * 'eventName', and 'subitems', which is another Array.
       *
       * @type {Array}
       * @default [{}]
       */
      navItems: {
        type: Array,
        notify: true,
        observer: '_handleNavItemsChanged'
      },

      /**
       * When navigating, this prefix is appended to the relative URL. Defaults to '#', indicating paths are routed via the
       * hash part of the URL.  To make them relative to current directory, use '/'.
       *
       * @type {String}
       * @default ["#"]
       */
      pathPrefix: {
        value : '#',
        type: String
      },

      /**
       * Allows a level of indirection in the Array of navItems passed in to resolve paths
       *
       * @type {String}
       * @default ["path"]
       */
      pathKey: {
        value: 'path',
        type: String
      },

      selectedItem: {
        type: Object,
        notify: true,
        readOnly: true
      },

      selectedSubitem: {
        type: Object,
        notify: true,
        readOnly: true
      },

      selectedPath: {
        type: String,
        notify: true,
        observer: '_selectedPathChanged'
      },

      selectedSubpath: {
        type: String,
        notify: true,
        observer: '_selectedPathChanged'
      },

      _availableWidth: {
        type: Number,
        observer: 'rebuild'
      },

      visibleItems: {
        type: Array,
        notify: true,
        readOnly: true
      },

      collapsedItems: {
        type: Array,
        notify: true,
        readOnly: true
      }
    },

    statics: {
      ITEM_FONT_NAME: 'GE Inspira Sans',
      ITEM_FONT_SIZE: 15,
      ITEM_PADDING: 32, /* 16+16 */
      ITEM_ICON_WIDTH: 30,
      ITEM_ICON_PADDING: 10,
      OPEN_ICON_WIDTH: 15,
      OPEN_ICON_PADDING: 5,
      OVERFLOW_ICON_SIZE: 30,
      OVERFLOW_ICON_PADDING: 32 /*16+16*/
    },

    listeners: {
      'iron-resize' : '_handleResize',
      'px-app-nav-item-tapped' : '_handleItemTapped'
    },

    _handleItemTapped: function(evt) {
      if (!evt.detail.path || !Array.isArray(evt.detail.path) || !evt.detail.path.length) return;

      if (evt.detail.path.length === 1) {
        this.set('selectedPath', evt.detail.items[0].path);
        this.set('selectedSubpath', null);
      }
      if (evt.detail.path.length === 2) {
        this.set('selectedPath', evt.detail.items[0].path);
        this.set('selectedSubpath', evt.detail.items[1].path);
      }
    },

    _selectedPathChanged() {
      this.debounce('selected-changed', () => {
        const nextPath = this.selectedPath;
        const nextSubpath = this.selectedSubpath;
        const lastItem = this.selectedItem;
        const lastSubitem = this.selectedSubitem;
        let changed = false;

        if (typeof nextPath !== 'string' || !nextPath.length) return;

        if (!lastItem) {
          changed = true;
        }

        if (lastItem && lastItem.path !== nextPath) {
          changed = true;
          this._deselectByItem(lastItem);
        }

        const hasSubpath = (typeof nextSubpath === 'string' && nextSubpath.length > 0);
        if (lastSubitem && (!hasSubpath || lastSubitem.path !== nextSubpath)) {
          changed = true;
          this._deselectByItem(lastSubitem);
        }

        if (changed) {
          this._selectPath(nextPath, nextSubpath);
        }
      });
    },

    _selectPath(path, subpath) {
      const [selectedNode, selectedSubnode] = this._findNodesByPath(path, subpath) || [];
      if (!selectedNode && !selectedSubnode) {
        let errPath = nextPath + (hasSubpath) ? '.' + nextSubpath : '';
        console.log(`PX-APP-NAV CONFIGURATION ERROR:
          The path '${errPath}' cannot be found. Enter a valid path.`);
        return;
      }
      if (selectedNode && this.selectedItem !== selectedNode.item) {
        this._setSelectedItem(selectedNode.item);
        selectedNode.set('selected', true);
      }
      if (selectedSubnode && this.selectedSubitem !== selectedSubnode.item) {
        this._setSelectedSubitem(selectedSubnode.item);
        selectedSubnode.set('selected', true);
      }
    },

    _deselectByItem(item) {
      const node = this._findNodeByProperty('item', item);
      if (node) {
        node.set('selected', false);
      }
    },

    _findNodeByProperty(propName, val, parent) {
      const nodes = Polymer.dom(parent ? parent : this.root).querySelectorAll('px-app-nav-item, px-app-nav-group');
      if (!nodes || !nodes.length) return;
      let itemNode;

      for (let node of nodes) {
        if (node[propName] === val) {
          itemNode = node;
          break;
        }
      }

      return itemNode;
    },

    _findNodesByPath(path, subpath) {
      let item, subitem;
      if (typeof path === 'string' && path.length) {
        node = this._findNodeByProperty('path', path);
        item = node ? node : undefined;
      }
      if (node && typeof subpath === 'string' && subpath.length) {
        childNode = this._findNodeByProperty('path', subpath, node);
        subitem = childNode ? childNode : undefined;
      }
      return [item, subitem];
    },

    created: function() {
      this._navAttached = false;
      this._navTarget;
    },

    attached: function() {
      this._navAttached = true;
      this._knownItems = [];
      this._detachedItems = [];
      // var boundItemHandler = this._handleItemsDistributed.bind(this);
      // this._itemObserver = Polymer.dom(this.$.new).observeNodes(boundItemHandler);
    },

    detached: function() {
      this._navAttached = false;
      this._knownItems = null;
      this._detachedItems = null;
      // Polymer.dom(this.$.new).unobserveNodes(this._itemObserver);
    },

    _handleResize: function(evt) {
      const debouncer = 'measure-available-width';
      if (typeof this._availableWidth !== 'number') {
        this._getAvailableWidth();
        return;
      }
      if (this.isDebouncerActive(debouncer)) {
        this.cancelDebouncer(debouncer);
      }
      this.debounce(debouncer, this._getAvailableWidth.bind(this), 100);
    },

    _getAvailableWidth: function() {
      window.requestAnimationFrame(() => {
        const el = this.$.items;
        if (!el) return;
        const width = el.getBoundingClientRect().width;
        if (this._availableWidth !== width) this.set('_availableWidth', width);
      });
    },

    _handleNavItemsChanged(items) {
      Polymer.RenderStatus.afterNextRender(this, this._buildNodesFromData, [items]);
    },

    _buildNodesFromData: function(items) {
      var nodes = items.map(this._buildNode.bind(this));
      this._detachedItems = this._detachedItems.concat(nodes);
      this._knownItems = this._knownItems.concat(nodes);
      this.rebuild();
    },

    _buildNode: function(item, parent) {
      var el;
      if (Array.isArray(item.subitems) && item.subitems.length) {
        el = document.createElement('px-app-nav-group');
        for (let subitem of item.subitems) {
          Polymer.dom(el).appendChild(this._buildNode(subitem, parent));
        }
      }
      else {
        el = document.createElement('px-app-nav-item');
      }
      if (item.label) el.setAttribute('label', item.label);
      if (item.icon)  el.setAttribute('icon', item.icon);
      if (item.path)  el.setAttribute('path', item.path);
      el.item = item;
      return el;
    },

    // _buildNodesInParent: function(items, parent) {
    //   var el;
    //   for (var i = 0, len = items.length; i < len; i++) {
    //     el = this._createNode(items[i]);
    //     if (Array.isArray(items[i].subitems) && items[i].subitems.length) {
    //       this._buildNodesInParent(items[i].subitems, el);
    //     }
    //     Polymer.dom(parent).appendChild(el);
    //   }
    //   return parent;
    // },
    //
    // _createNode: function(item) {
    //   var el;
    //   if (Array.isArray(item.subitems) && item.subitems.length) {
    //     el = document.createElement('px-app-nav-group');
    //   }
    //   else {
    //     el = document.createElement('px-app-nav-item');
    //   }
    //   if (item.label) el.setAttribute('label', item.label);
    //   if (item.icon)  el.setAttribute('icon', item.icon);
    //   if (item.path)
    //   return el;
    // },

    _handleItemsDistributed: function(info) {
      // if (Array.isArray(info.addedNodes) && info.addedNodes.length) {
      //   var addedItems = this._findItemNodes(info.addedNodes);
      //   this._newItems = this._newItems.concat(addedItems);
      //   this.rebuild();
      // }
      //
      // if (Array.isArray(info.removedNodes) && info.removedNodes.length) {
      //   var removedItems = this._findItemNodes(info.removedNodes);
      //   this._knownItems = this._untrackItems(removedItems);
      // }
    },

    _trackItems(items, knownItems) {
      // return items.reduce(function(accum, item) {
      //   if (accum.indexOf(item) === -1) {
      //     accum.push(item);
      //   }
      //   return accum;
      // }, knownItems);
    },

    _untrackItems(items, knownItems) {
      // return knownItems.filter(function(item) {
      //   return items.indexOf(item) === -1;
      // });
    },

    _findItemNodes(nodes) {
      // var found = [];
      // var i = 0;
      // var len = nodes.length;
      // for (; i < len; i++) {
      //   if (nodes[i].nodeType === Node.ELEMENT_NODE && (nodes[i].nodeName === 'PX-APP-NAV-GROUP' || nodes[i].nodeName === 'PX-APP-NAV-ITEM')) {
      //     found.push(nodes[i]);
      //   }
      // }
      // return found;
    },

    /**
     * Rebuilds the nav to reflect its `type` and `collapseAll` settings.
     */
    rebuild: function() {
      if (this._pendingRender || typeof this.type !== 'string' || typeof this.collapseAll !== 'boolean' || !Array.isArray(this._knownItems) || !this._knownItems.length || !this._availableWidth) return;
      this._pendingRender = true;

      const items = this._knownItems;
      const width = this._availableWidth;
      const pMeasure = () => this._measureItems(items);
      const pFit = (measurements) => this._fitItems(items, width, measurements);
      const pRender = ({visible, collapsed}) => this._renderItems(items, visible, collapsed);
      const pFinish = ({visible, collapsed}) => {
        this._pendingRender = false;
        this._updateItemsProp('visibleItems', visible, true);
        this._updateItemsProp('collapsedItems', collapsed, true);
        return Promise.resolve();
      };
      const pAll = () => pMeasure().then(pFit).then(pRender).then(pFinish);

      // Polymer.RenderStatus.afterNextRender(this, pAll);
      pAll.call();
    },

    _updateItemsProp: function(propName, items, readOnly) {
      const setter = readOnly ? this[`_set${propName.slice(0,1).toUpperCase()}${propName.slice(1)}`].bind(this) : this.set.bind(this, propName);
      if (items.length) {
        setter(items);
      } else {
        setter([]);
      }
      if (this[propName] && Array.isArray(this[propName])) {
        const splices = Polymer.ArraySplice.calculateSplices(this[propName], items);
      }
    },

    _renderItems: function(items, visible, collapsed) {
      const renderers = items.map(item =>
        this._renderItem(item, (collapsed.indexOf(item) > -1))
      );
      return Promise.all(renderers).then(() => ({ items: items, visible: visible, collapsed: collapsed }));
    },

    _renderItem: function(item, isCollapsed=false) {
      const newParent = isCollapsed ? this.$.collapsed : this.$.visible;
      const currentParent = Polymer.dom(item).parentNode;
      if (!currentParent) {
        Polymer.dom(newParent).appendChild(item);
      }
      if (currentParent && currentParent !== newParent) {
        Polymer.dom(currentParent).appendChild(item);
        Polymer.dom(newParent).appendChild(item);
      }
      return Promise.resolve();
    },

    _fitItems: function(items, width, measurements) {
      return new Promise((resolve, reject) => {
        console.time('fit');
        let available = width;

        // If the first item is larger than the available, collapse all
        if (available < measurements[0]) {
          return resolve({ visible: [], collapsed: items.slice(0) });
        }

        // Try to fit items in the available space
        let i = 0;
        let len = items.length;

        while (i<len && available>0) {
          if (measurements[i] > available) {
            break;
          }
          available -= measurements[i];
          i++;
        }

        // If any overflow, ensure the overflow icon can fit
        let overflowSize = this.statics.OVERFLOW_ICON_SIZE + this.statics.OVERFLOW_ICON_PADDING;
        if (i !== len && available < overflowSize) {
          available -= overflowSize;
          while (i>0 && available<0) {
            available += measurements[i];
            i--;
          }
        }
        console.timeEnd('fit');
        return resolve({ visible: items.slice(0,i), collapsed: items.slice(i) });
      })
    },

    _measureItems: function(items) {
      const boundMeasureFn = this._measureItem.bind(this);
      const measurements = items.map(boundMeasureFn);
      return Promise.all(measurements);
    },

    _measureItem: function(item) {
      const getLength = this._measureTextAsync(item.label, this.statics.ITEM_FONT_NAME, this.statics.ITEM_FONT_SIZE + 'px');
      return getLength.then((textLength) => {
        if (!textLength) return Promise.reject(`The text ${item.label} could not be measured.`);
        let totalLength = textLength; /* start with text size */
        totalLength += this.statics.ITEM_PADDING; /* add left pad + right pad */
        if (item.icon && item.icon.length) totalLength += (this.statics.ITEM_ICON_WIDTH + this.statics.ITEM_ICON_PADDING); /* add icon size + icon right pad */
        if (item.nodeName === 'PX-APP-NAV-GROUP') totalLength += (this.statics.OPEN_ICON_WIDTH + this.statics.OPEN_ICON_PADDING); /* add dropdown icon size + dropdown icon left pad */
        return Promise.resolve(totalLength);
      });
    },

    _measureTextAsync: function(text, fontName, fontSize) {
      return new Promise(function(resolve, reject) {
        return resolve(this._measureText(text, fontName, fontSize));
      }.bind(this));
    },

    _measureText: function(text, fontName, fontSize) {
      var cv = this._get2dMeasureCanvas(fontName, fontSize);
      var size = cv.measureText(text).width;
      return isNaN(size) ? undefined : Math.round(size);
    },

    _get2dMeasureCanvas: function(fontName, fontSize) {
      this.__measureCanvasCache = this.__measureCanvasCache || {};
      var fontInfo = fontSize + ' ' + fontName;
      if (this.__measureCanvasCache[fontInfo]) return this.__measureCanvasCache[fontInfo];
      var cv = document.createElement('canvas');
      cv.height = 999;
      cv.width = 999;
      var ctx = cv.getContext('2d');
      ctx.font = fontInfo;
      return (this.__measureCanvasCache[fontInfo] = ctx);
    },

    _attachChild(child) {
      Polymer.dom(this.$.visible).appendChild(child);
    },

    _rebuildItems: function() {

    },

    _moveToTarget: function(el, lastParent, nextParent) {
      // if (!el || !lastParent || !nextParent) return;
      //
      // Polymer.dom(lastParent).removeChild(el);
      // Polymer.dom(nextParent).appendChild(el);
    },

    _ensureItemsInTarget(items, target) {
      // var i = 0;
      // var len = items.length;
      // var parentNode;
      // var anyMoved = false;
      //
      // for (; i < len; i++) {
      //   parentNode = Polymer.dom(items[i]).parentNode;
      //   if (parentNode && parentNode !== target) {
      //     Polymer.dom(parentNode).removeChild(items[i]);
      //     Polymer.dom(target).appendChild(items[i]);
      //     anyMoved = true;
      //   }
      // }
      //
      // if (anyMoved) {
      //   Polymer.dom.flush();
      // }
    },

    _getNavTarget: function(type, collapsed) {
      if (collapsed && type === 'horizontal') {
        return this.$.collapsed;
      }
      if (!collapsed && type === 'horizontal') {
        return this.$.horizontal;
      }
      if (type === 'vertical') {
        return this.$.vertical;
      }
    },

    /**
     * Handles selection events that bubble up from subcomponents.
     */
    _handlePathSelected: function(evt) {
      // var path = evt.detail.path || [];
      // if (path.length) {
      //   var pathStr = '';
      // }
    },

    /**
     * Selects an item by its path or its index.
     *
     * To select an item, just provide its path. For example, select the Dashboards
     * item (which has path 'dashboards') with `select('dashboards')`
     *
     * To select an item inside a group, provide a sub-path. For example, select
     * the first case (which has path 'case1') inside the Cases group (which has
     * path 'cases') with `select('cases.case1')`.
     *
     * Note that individual path names cannot have dots ('.') in them or they
     * cannot be selected.
     *
     * If an item is found, it will be returned after it is selected. If no item
     * is found, return will be undefined.
     *
     * @param {Number|String} item
     * @return {HTMLElement|undefined}
     */
    select: function(item) {
      var selectedItem;

      // If a string as a trailing dot ('foo.') clean the dot off
      if (typeof item === 'string' && item.length > 0 && item.indexOf('.') === (item.length - 1)) {
        item = item.substr(0, (item.length - 1));
      }
      // If the item is a string with subpaths, split and select each
      if (typeof item === 'string' && item.length && item.indexOf('.') !== -1) {
        item = item.split('.');
        selectedItem = this._selectItems(item);
      }
      else if (typeof item === 'string' && item.length) {
        selectedItem = this._selectItem(item, 'path');
      }
      else if (typeof item === 'number') {
        selectedItem = this._selectItem(item, 'index');
      }

      return selectedItem;
    },

    /**
     * Selects an item directly. If an (item[prop] === val), the item will be
     * selected. If an item is found, it will be returned after it is selected.
     * If no item is found, return will be undefined.
     *
     * @return {HTMLElement|undefined}
     */
    _selectItem(val, prop) {
      var items = this.$.selector.items;
      if (!items || !items.length) return;

      var itemToSelect = this._findItem(items, val, prop);
      if (itemToSelect && !itemToSelect.selected) {
        itemToSelect.set('selected', true);
      }

      return itemToSelect;
    },

    /**
     * Selects an item inside a group. `refs[0]` should be an index or path of
     * a group. `refs[1]` should be an index or path of an item in that group.
     *
     * If an item is found, it will be returned after it is selected. If no item
     * is found, return will be undefined.
     *
     * @return {HTMLElement|undefined}
     */
    _selectItems(refs) {
      var items = this.$.selector.items;
      if (!items || !items.length) return;

      // Convert the group or item ref to a number, if it can be converted.
      // Otherwise it will stay a string.
      var groupRef = this._castStrToNum(refs[0]);
      var itemRef = this._castStrToNum(refs[1]);

      var groupToSelect = this._findItem(items, groupRef, (typeof groupRef === 'string') ? 'path' : 'index');
      var itemToSelect;
      if (groupToSelect && (typeof groupToSelect.select === 'function')) {
        selectItem = groupToSelect.select(itemRef);
      }

      return itemToSelect;
    },

    /**
     * Finds and returns an item that passes the test `item[prop] === val` or
     * returns undefined.
     *
     * @param {Array} items - An array of `HTMLElement` to search
     * @param {String|Number} val
     * @param {String} prop - The property to check
     * @returns {HTMLElement|undefined}
     *
     */
    _findItem(items, val, prop) {
      var found;
      var i = 0;
      var len = items.length;

      for (; i<len; i++) {
        if (typeof items[i][prop] !== 'undefined' && items[i][prop] === val) {
          found = items[i];
          break;
        }
      }

      return found;
    },

    /**
     * If the string can be casted to a number, casts it. Otherwise, returns
     * the original string.
     */
    _castStrToNum: function(str) {
      return (typeof str === 'string' && !isNaN(str)) ? parseInt(str) : str;
    },


    /**
     * Helps check if items generated from data have subitems.
     */
    _hasSubitems(item) {
      return item && Array.isArray(item.subitems) && item.subitems.length;
    },

    /**
     * Helps check if items generated from data have subitems.
     */
    _hasNoSubitems(item) {
      return !item.hasOwnProperty('subitems');
    },

    _getNavClasses(type, collapsed) {
      var className = 'app-nav';

      if (type === 'horizontal') {
        className += ' app-nav--horizontal'
      }
      if (collapsed === true && type === 'horizontal') {
        className += ' app-nav--collapsed'
      }
      if (type === 'vertical') {
        className += ' app-nav--vertical'
      }

      return className;
    },

    _navIs(isType, wantedType, isCollapsed, wantedCollapsed) {
      // If nav should be collapsed and it is not, return false...
      if (typeof wantedCollapsed === 'string' && wantedCollapsed === 'collapsed' && !isCollapsed) {
        return false;
      }
      // Next, check type
      if (wantedType === 'horizontal' && isType !== 'horizontal') {
        return false;
      }
      if (wantedType === 'vertical' && isType !== 'vertical') {
        return false;
      }
      return true;
    },

    _getCollapsedButtonClasses(collapsedItems, selectedItem) {
      let classNames = [];
      if (collapsedItems && Array.isArray(collapsedItems) && collapsedItems.length) {
        classNames.push('app-nav-items__collapse-button--visible');
      }
      if (selectedItem && collapsedItems && Array.isArray(collapsedItems) && collapsedItems.indexOf(selectedItem) !== -1) {
        classNames.push('app-nav-items__collapse-button--selected');
      }
      return classNames.join(' ');
    }
  });
</script>
