<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<link rel="import" href="../polymer/polymer.html">
<!-- <link rel="import" href="../px-tooltip/px-tooltip.html"> -->
<!-- <link rel="import" href="../neon-animation/neon-animation.html"> -->

<link rel="import" href="../px-polymer-font-awesome/px-polymer-font-awesome.html" />
<link rel="import" href="../app-layout/app-toolbar/app-toolbar.html" />
<link rel="import" href="../app-layout/app-header/app-header.html" />
<link rel="import" href="../iron-dropdown/iron-dropdown.html" />
<link rel="import" href="../iron-selector/iron-selector.html" />

<link rel="import" href="px-app-nav-horizontal.html" />
<link rel="import" href="px-app-nav-collapsed.html" />
<link rel="import" href="px-app-nav-list.html" />
<link rel="import" href="px-app-nav-group.html" />

<link rel="import" href="px-app-nav-item.html" />
<link rel="import" href="px-app-nav-subitem.html" />

<!--

#### Usage

    <px-app-nav
        nav-items='[{"path": "", "icon": "fa-exclamation-triangle", "label":"//alerts","subitems": [{"label": "Sub Category 1"}, {"label": "Sub Category 2"}]},{"path": "tab2", "icon": "fa-briefcase", "label": "Cases"}]'
            <any-arbitrary-content></any-arbitrary-content>
            <div class="auth">
                <any-auth-control></any-auth-control>
            </div>
    </px-app-nav>

#### Styling
The following custom properties are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--px-app-nav-background-color` | Background color for the app navigation component | `$gray10`
`--px-app-nav-link-text-color` | Text color for the nav items | `$white`
`--px-app-nav-link-hover-color` | Background color for a nav item when a user hovers over one | `$gray8`
`--px-app-nav-link-selected-active-color` | Background color for a nav item when a user clicks on one | `$select-blue-hover`
`--px-app-nav-link-selected-color` | Background color for the selected nav item | `$select-blue-pressed`
`--px-app-nav-hamburger-button-color` | Fill color for the hamburger menu icon | `$white`

@element px-app-nav
@blurb Nav bar / drawer for applications.
@homepage index.html
@demo index.html
-->

<link rel="import" href="css/px-app-nav-styles.html">

<dom-module id="px-app-nav">
  <template>
    <style include="px-app-nav-styles"></style>
    <style>
      #root {
        display: none;
      }
      .app-nav-toolbar-collapsed {
        display: none;
      }
      .app-nav--collapsed .app-nav-toolbar-collapsed {
        display: inherit;
      }
    </style>

    <section class$="{{_getNavClasses(type, collapseAll)}}">
      <app-header fixed>
        <app-toolbar class="app-nav-toolbar" id="toolbar">
          <!-- If nav `type` is horizontal and `collapseAll` is false it will be placed here -->
          <div class="app-nav-toolbar-horizontal">
            <px-app-nav-horizontal id="horizontal"></px-app-nav-horizontal>
          </div>

          <!-- If nav `type` is horizontal and `collapseAll` is true it will be placed here -->
          <div class="app-nav-toolbar-collapsed">
            <px-app-nav-collapsed id="collapsed" label="{{selectedItem.label}}" icon="{{selectedItem.icon}}"></px-app-nav-collapsed>
          </div>

          <!-- If nav `type` is vertical it will be placed here -->
          <div class="app-nav-toolbar-vertical" id="vertical">
          </div>
        </app-toolbar>
      </app-header>
    </section>

    <section id="root">
      <!-- Distribute nav items passed as light DOM children -->
      <content select="*"></content>

      <!-- Create nav items from data -->
      <template is="dom-repeat" items="{{navItems}}">
        <!-- Stamp groups, which hold subitems -->
        <template is="dom-if" if="{{_hasSubitems(item)}}">
          <px-app-nav-group label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}">
            <template is="dom-repeat" items="{{item.subitems}}" as="subitem">
              <px-app-nav-item label="{{subitem.label}}" path="{{subitem.path}}"></px-app-nav-item>
            </template>
          </px-app-nav-group>
        </template>

        <!-- Stamp plain old items, which hold subitems -->
        <template is="dom-if" if="{{_hasNoSubitems(item)}}">
          <px-app-nav-item label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}">
          </px-app-nav-item>
        </template>
      </template>
    </section>

  </template>
</dom-module>

<script>
  Polymer({
    is: 'px-app-nav',

    properties: {
      /**
       * Set to 'horizontal' to display nav across the top of the screen, or set
       * to 'vertical' to display navigation along the side of the screen.
       */
      type: {
        type: String,
        value: 'horizontal',
        observer: 'rebuild'
      },

      /**
       * Set to `true` to collapse all nav items (including top-level items)
       * into a dropdown and only show the active item in the nav.
       *
       * Only works if the the nav `type` is horizontal.
       */
      collapseAll: {
        type: Boolean,
        value: false,
        observer: 'rebuild'
      },

      /**
       * Selects a path.
       */
      selectedPath: {
        type: String,
        notify: true,
        observer: '_selectedPathChanged'
      },

      /**
       * Object array of items and sub-items in the nav. Each object in the Array can specify '[path-key]', 'label', 'icon'
       * 'eventName', and 'subitems', which is another Array.
       *
       * @type {Array}
       * @default [{}]
       */
      navItems: {
        type: Array,
        notify: true,
        value: function() {
          return [{}];
        }
      },

      /**
       * When navigating, this prefix is appended to the relative URL. Defaults to '#', indicating paths are routed via the
       * hash part of the URL.  To make them relative to current directory, use '/'.
       *
       * @type {String}
       * @default ["#"]
       */
      pathPrefix: {
        value : '#',
        type: String
      },

      /**
       * Allows a level of indirection in the Array of navItems passed in to resolve paths
       *
       * @type {String}
       * @default ["path"]
       */
      pathKey: {
        value: 'path',
        type: String
      },

      selectedItem: {
        type: Object,
        notify: true
      },

      selectedSubitem: {
        type: Object,
        notify: true
      },
    },

    created: function() {
      this._navAttached = false;
      this._navTarget;
      this._knownItems;
    },

    attached: function() {
      this._knownItems = [];
      var boundItemHandler = this._handleItemsUpdated.bind(this);
      this._itemObserver = Polymer.dom(this.$.root).observeNodes(boundItemHandler);
    },

    detached: function() {
      this._knownItems = null;
      Polymer.dom(this.$.root).unobserveNodes(this._itemObserver);
    },

    _handleItemsUpdated: function(info) {
      if (Array.isArray(info.addedNodes) && info.addedNodes.length) {
        var addedItems = this._findItemNodes(info.addedNodes);
        this._knownItems = this._trackItems(addedItems, this._knownItems);
      }
      this.rebuild();
      // if (Array.isArray(info.removedNodes) && info.removedNodes.length) {
      //   var removedItems = this._findItemNodes(info.removedNodes);
      //   this._knownItems = this._untrackItems(removedItems);
      // }
    },

    _trackItems(items, knownItems) {
      return items.reduce(function(accum, item) {
        if (accum.indexOf(item) === -1) {
          accum.push(item);
        }
        return accum;
      }, knownItems);
    },

    _untrackItems(items, knownItems) {
      return knownItems.filter(function(item) {
        return items.indexOf(item) === -1;
      });
    },

    _findItemNodes(nodes) {
      var found = [];
      var i = 0;
      var len = nodes.length;
      for (; i < len; i++) {
        if (nodes[i].nodeType === Node.ELEMENT_NODE && (nodes[i].nodeName === 'PX-APP-NAV-GROUP' || nodes[i].nodeName === 'PX-APP-NAV-ITEM')) {
          found.push(nodes[i]);
        }
      }
      return found;
    },

    /**
     * Rebuilds the nav to reflect its `type` and `collapseAll` settings.
     */
    rebuild: function() {
      if (typeof this.type !== 'string' || typeof this.collapseAll !== 'boolean' || !Array.isArray(this._knownItems) || !this._knownItems.length) return;

      var target = this._getNavTarget(this.type, this.collapseAll);
      this._ensureItemsInTarget(this._knownItems, target);
    },

    _ensureItemsInTarget(items, target) {
      var i = 0;
      var len = items.length;
      var parentNode;
      var anyMoved = false;

      for (; i < len; i++) {
        parentNode = Polymer.dom(items[i]).parentNode;
        if (parentNode && parentNode !== target) {
          Polymer.dom(parentNode).removeChild(items[i]);
          Polymer.dom(target).appendChild(items[i]);
          anyMoved = true;
        }
      }

      if (anyMoved) {
        Polymer.dom.flush();
      }
    },

    _getNavTarget: function(type, collapsed) {
      if (collapsed && type === 'horizontal') {
        return this.$.collapsed;
      }
      if (!collapsed && type === 'horizontal') {
        return this.$.horizontal;
      }
      if (type === 'vertical') {
        return this.$.vertical;
      }
    },

    /**
     * Handles selection events that bubble up from subcomponents.
     */
    _handlePathSelected: function(evt) {
      // var path = evt.detail.path || [];
      // if (path.length) {
      //   var pathStr = '';
      // }
    },

    _selectedPathChanged: function(nextPath, lastPath) {

    },

    /**
     * Selects an item by its path or its index.
     *
     * To select an item, just provide its path. For example, select the Dashboards
     * item (which has path 'dashboards') with `select('dashboards')`
     *
     * To select an item inside a group, provide a sub-path. For example, select
     * the first case (which has path 'case1') inside the Cases group (which has
     * path 'cases') with `select('cases.case1')`.
     *
     * Note that individual path names cannot have dots ('.') in them or they
     * cannot be selected.
     *
     * If an item is found, it will be returned after it is selected. If no item
     * is found, return will be undefined.
     *
     * @param {Number|String} item
     * @return {HTMLElement|undefined}
     */
    select: function(item) {
      var selectedItem;

      // If a string as a trailing dot ('foo.') clean the dot off
      if (typeof item === 'string' && item.length > 0 && item.indexOf('.') === (item.length - 1)) {
        item = item.substr(0, (item.length - 1));
      }
      // If the item is a string with subpaths, split and select each
      if (typeof item === 'string' && item.length && item.indexOf('.') !== -1) {
        item = item.split('.');
        selectedItem = this._selectItems(item);
      }
      else if (typeof item === 'string' && item.length) {
        selectedItem = this._selectItem(item, 'path');
      }
      else if (typeof item === 'number') {
        selectedItem = this._selectItem(item, 'index');
      }

      return selectedItem;
    },

    /**
     * Selects an item directly. If an (item[prop] === val), the item will be
     * selected. If an item is found, it will be returned after it is selected.
     * If no item is found, return will be undefined.
     *
     * @return {HTMLElement|undefined}
     */
    _selectItem(val, prop) {
      var items = this.$.selector.items;
      if (!items || !items.length) return;

      var itemToSelect = this._findItem(items, val, prop);
      if (itemToSelect && !itemToSelect.selected) {
        itemToSelect.set('selected', true);
      }

      return itemToSelect;
    },

    /**
     * Selects an item inside a group. `refs[0]` should be an index or path of
     * a group. `refs[1]` should be an index or path of an item in that group.
     *
     * If an item is found, it will be returned after it is selected. If no item
     * is found, return will be undefined.
     *
     * @return {HTMLElement|undefined}
     */
    _selectItems(refs) {
      var items = this.$.selector.items;
      if (!items || !items.length) return;

      // Convert the group or item ref to a number, if it can be converted.
      // Otherwise it will stay a string.
      var groupRef = this._castStrToNum(refs[0]);
      var itemRef = this._castStrToNum(refs[1]);

      var groupToSelect = this._findItem(items, groupRef, (typeof groupRef === 'string') ? 'path' : 'index');
      var itemToSelect;
      if (groupToSelect && (typeof groupToSelect.select === 'function')) {
        selectItem = groupToSelect.select(itemRef);
      }

      return itemToSelect;
    },

    /**
     * Finds and returns an item that passes the test `item[prop] === val` or
     * returns undefined.
     *
     * @param {Array} items - An array of `HTMLElement` to search
     * @param {String|Number} val
     * @param {String} prop - The property to check
     * @returns {HTMLElement|undefined}
     *
     */
    _findItem(items, val, prop) {
      var found;
      var i = 0;
      var len = items.length;

      for (; i<len; i++) {
        if (typeof items[i][prop] !== 'undefined' && items[i][prop] === val) {
          found = items[i];
          break;
        }
      }

      return found;
    },

    /**
     * If the string can be casted to a number, casts it. Otherwise, returns
     * the original string.
     */
    _castStrToNum: function(str) {
      return (typeof str === 'string' && !isNaN(str)) ? parseInt(str) : str;
    },


    /**
     * Helps check if items generated from data have subitems.
     */
    _hasSubitems(item) {
      return item && Array.isArray(item.subitems) && item.subitems.length;
    },

    /**
     * Helps check if items generated from data have subitems.
     */
    _hasNoSubitems(item) {
      return !item.hasOwnProperty('subitems');
    },

    _getNavClasses(type, collapsed) {
      var className = 'app-nav';

      if (type === 'horizontal') {
        className += ' app-nav--horizontal'
      }
      if (collapsed === true && type === 'horizontal') {
        className += ' app-nav--collapsed'
      }
      if (type === 'vertical') {
        className += ' app-nav--vertical'
      }

      return className;
    },

    _navIs(isType, wantedType, isCollapsed, wantedCollapsed) {
      // If nav should be collapsed and it is not, return false...
      if (typeof wantedCollapsed === 'string' && wantedCollapsed === 'collapsed' && !isCollapsed) {
        return false;
      }
      // Next, check type
      if (wantedType === 'horizontal' && isType !== 'horizontal') {
        return false;
      }
      if (wantedType === 'vertical' && isType !== 'vertical') {
        return false;
      }
      return true;
    }
  });
</script>
