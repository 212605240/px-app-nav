<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<link rel="import" href="../polymer/polymer.html">
<!-- <link rel="import" href="../px-tooltip/px-tooltip.html"> -->
<!-- <link rel="import" href="../neon-animation/neon-animation.html"> -->

<link rel="import" href="../px-polymer-font-awesome/px-polymer-font-awesome.html" />
<link rel="import" href="../app-layout/app-toolbar/app-toolbar.html" />
<link rel="import" href="../app-layout/app-header/app-header.html" />
<link rel="import" href="../iron-dropdown/iron-dropdown.html" />
<link rel="import" href="../iron-selector/iron-selector.html" />
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html" />

<link rel="import" href="px-app-nav-horizontal.html" />
<link rel="import" href="px-app-nav-collapsed.html" />
<link rel="import" href="px-app-nav-list.html" />
<link rel="import" href="px-app-nav-group.html" />

<link rel="import" href="px-app-nav-item.html" />
<link rel="import" href="px-app-nav-subitem.html" />

<!--

#### Usage

    <px-app-nav
        nav-items='[{"path": "", "icon": "fa-exclamation-triangle", "label":"//alerts","subitems": [{"label": "Sub Category 1"}, {"label": "Sub Category 2"}]},{"path": "tab2", "icon": "fa-briefcase", "label": "Cases"}]'
            <any-arbitrary-content></any-arbitrary-content>
            <div class="auth">
                <any-auth-control></any-auth-control>
            </div>
    </px-app-nav>

#### Styling
The following custom properties are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--px-app-nav-background-color` | Background color for the app navigation component | `$gray10`
`--px-app-nav-link-text-color` | Text color for the nav items | `$white`
`--px-app-nav-link-hover-color` | Background color for a nav item when a user hovers over one | `$gray8`
`--px-app-nav-link-selected-active-color` | Background color for a nav item when a user clicks on one | `$select-blue-hover`
`--px-app-nav-link-selected-color` | Background color for the selected nav item | `$select-blue-pressed`
`--px-app-nav-hamburger-button-color` | Fill color for the hamburger menu icon | `$white`

@element px-app-nav
@blurb Nav bar / drawer for applications.
@homepage index.html
@demo index.html
-->

<link rel="import" href="css/px-app-nav-styles.html">

<dom-module id="px-app-nav">
  <template>
    <style include="px-app-nav-styles">
      #root {
        display: none;
      }
      .app-nav-toolbar-collapsed {
        display: none;
      }
      .app-nav--collapsed .app-nav-toolbar-collapsed {
        display: inherit;
      }
      .app-nav-visible {
        display: flex;
      }
      .app-nav-collapsed {
        display: none;
      }
      .app-nav-toolbar {
        background-color: rgb(223, 230, 234);
        box-shadow: rgba(0, 0, 0, 0.298039) 0px 1px 3px;
        height: 60px;
        padding-left: 0;
        padding-right: 0;
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        max-width: 100%;
      }
      .app-nav-items {
        height: 60px;
        flex: 1;
        display: flex;
        max-width: 100%;
      }
    </style>
    <section class$="{{_getNavClasses(collapseAll, vertical)}}">
      <app-header fixed>
        <app-toolbar class="app-nav-toolbar" id="toolbar">
          <section class="app-nav-items" id="items">
            <template is="dom-repeat" items="{{navItems}}" filter="_isItemVisible" id="visible">
              <!-- Stamp groups, which hold subitems -->
              <template is="dom-if" if="{{_hasSubitems(item)}}">
                <px-app-nav-group label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}" selected$="{{_isItemSelected(item, selectedItem)}}">
                  <template is="dom-repeat" items="{{item.subitems}}" as="subitem">
                    <px-app-nav-item label="{{subitem.label}}" path="{{subitem.path}}" selected$="{{_isItemSelected(subitem, selectedSubitem)}}"></px-app-nav-item>
                  </template>
                </px-app-nav-group>
              </template>

              <!-- Stamp plain old items, which hold subitems -->
              <template is="dom-if" if="{{_hasNoSubitems(item)}}">
                <px-app-nav-item label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}" selected$="{{_isItemSelected(item, selectedItem)}}">
                </px-app-nav-item>
              </template>
            </template>

            <!-- <div class="app-nav-visible" id="visible"></div>
            <div class="app-nav-collapsed" id="collapsed"></div> -->

            <!-- STATE: Some nav items collapsed -->
            <template is="dom-if" if="{{_someCollapsed(collapsedItems, visibleItems)}}">
              <px-app-nav-group
                  superlist
                  min-width="320"
                  id="collapsedGroup"
                  label="{{_getCollapsedLabel(selectedItem, collapsedItems, visibleItems)}}"
                  icon="{{_getCollapsedIcon(selectedItem, collapsedItems, visibleItems)}}"
                  selected$="{{_ifSelectedCollapsed(selectedItem, collapsedItems)}}">
                <template is="dom-repeat" items="{{navItems}}" filter="_isItemCollapsed" id="collapsed">
                  <!-- Stamp groups, which hold subitems -->
                  <template is="dom-if" if="{{_hasSubitems(item)}}">
                    <px-app-nav-group label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}" selected$="{{_isItemSelected(item, selectedItem)}}">
                      <template is="dom-repeat" items="{{item.subitems}}" as="subitem">
                        <px-app-nav-item label="{{subitem.label}}" path="{{subitem.path}}" selected$="{{_isItemSelected(subitem, selectedSubitem)}}"></px-app-nav-item>
                      </template>
                    </px-app-nav-group>
                  </template>

                  <!-- Stamp plain old items, which hold subitems -->
                  <template is="dom-if" if="{{_hasNoSubitems(item)}}">
                    <px-app-nav-item label="{{item.label}}" icon="{{item.icon}}" path="{{item.path}}" selected$="{{_isItemSelected(item, selectedItem)}}">
                    </px-app-nav-item>
                  </template>
                </template>
              </px-app-nav-group>
            </template>

            <!-- STATE: All nav items collapsed -->
            <!-- <template is="dom-if" if="{{_allCollapsed(collapsedItems, visibleItems)}}">
              <px-app-nav-group
                  superlist
                  min-width="320"
                  id="collapsedGroup"
                  label="{{_getSelectedItemLabel(selectedItem.label)}}"
                  icon="{{selectedItem.icon}}">
              </px-app-nav-group>
            </template> -->

          </section>
        </app-toolbar>
      </app-header>
    </section>

  </template>
</dom-module>

<script>
  Polymer({
    is: 'px-app-nav',
    behaviors: [Polymer.IronResizableBehavior],

    properties: {
      initialCount: {
        type: Number,
        value: 3
      },

      /**
       * Set to 'horizontal' to display nav across the top of the screen, or set
       * to 'vertical' to display navigation along the side of the screen.
       */
      // type: {
      //   type: String,
      //   value: 'horizontal',
      //   observer: 'rebuild'
      // },

      vertical: {
        type: Boolean,
        value: false,
        observer: 'rebuild'
      },

      /**
       * Set to `true` to collapse all nav items (including top-level items)
       * into a dropdown and only show the active item in the nav.
       *
       * Only works if the the nav `type` is horizontal.
       */
      collapseAll: {
        type: Boolean,
        value: false,
        observer: '_handleCollapseAllChanged'
      },

      /**
       * Object array of items and sub-items in the nav. Each object in the Array can specify '[path-key]', 'label', 'icon'
       * 'eventName', and 'subitems', which is another Array.
       *
       * @type {Array}
       * @default [{}]
       */
      navItems: {
        type: Array,
        notify: true,
        observer: '_handleNavItemsChanged'
      },

      /**
       * When navigating, this prefix is appended to the relative URL. Defaults to '#', indicating paths are routed via the
       * hash part of the URL.  To make them relative to current directory, use '/'.
       *
       * @type {String}
       * @default ["#"]
       */
      pathPrefix: {
        value : '#',
        type: String
      },

      /**
       * Allows a level of indirection in the Array of navItems passed in to resolve paths
       *
       * @type {String}
       * @default ["path"]
       */
      pathKey: {
        value: 'path',
        type: String
      },

      selectedItem: {
        type: Object,
        notify: true,
        readOnly: true,
        value: null
      },

      selectedSubitem: {
        type: Object,
        notify: true,
        readOnly: true
      },

      selectedPath: {
        type: String,
        notify: true,
        observer: '_selectedPathChanged'
      },

      selectedSubpath: {
        type: String,
        notify: true,
        observer: '_selectedPathChanged'
      },

      _availableWidth: {
        type: Number,
        observer: 'rebuild'
      },

      visibleItems: {
        type: Array,
        notify: true,
        readOnly: true
      },

      collapsedItems: {
        type: Array,
        notify: true,
        readOnly: true
      },

      unselectedText: {
        type: String,
        value: 'Choose item'
      },

      fallbackPath: {
        type: String
      },

      fallbackSubpath: {
        type: String
      }
    },

    statics: {
      ITEM_FONT_NAME: 'GE Inspira Sans',
      ITEM_FONT_SIZE: 15,
      ITEM_PADDING: 32, /* 16+16 */
      ITEM_ICON_WIDTH: 30,
      ITEM_ICON_PADDING: 10,
      OPEN_ICON_WIDTH: 15,
      OPEN_ICON_PADDING: 5,
      OVERFLOW_ICON_SIZE: 30,
      OVERFLOW_ICON_PADDING: 32 /*16+16*/
    },

    observers: [
      '_selectedPathChanged(fallbackPath, navItems)',
      '_itemVisibilityChanged(visibleItems, collapsedItems, visibleItems.*, collapsedItems.*)'
    ],

    listeners: {
      'iron-resize' : '_sizeChanged',
      'px-app-nav-item-tapped' : '_handleItemTapped'
    },

    _getCollapsedLabel: function(selectedItem, collapsed, visible) {
      const someCollapsed = this._someCollapsed(collapsed, visible);
      const allCollapsed = this._allCollapsed(collapsed, visible);
      if (someCollapsed && !allCollapsed) {
        return undefined;
      }
      if (allCollapsed && selectedItem && typeof selectedItem === 'object') {
        return selectedItem.label;
      }
      if (allCollapsed && !selectedItem) {
        return this.unselectedText;
      }
    },

    _getCollapsedIcon: function(selectedItem, collapsed, visible) {
      const someCollapsed = this._someCollapsed(collapsed, visible);
      const allCollapsed = this._allCollapsed(collapsed, visible);
      if (someCollapsed && !allCollapsed) {
        return 'fa:fa-angle-double-right';
      }
      if (allCollapsed && selectedItem && typeof selectedItem === 'object') {
        return selectedItem.icon;
      }
      if (allCollapsed && !selectedItem) {
        return undefined;
      }
    },

    _isItemSelected: function(item, selectedItem) {
      return item && selectedItem && item === selectedItem;
    },

    _isItemVisible: function(item) {
      if (!item || !this.visibleItems || !Array.isArray(this.visibleItems)) return false;
      return this.visibleItems.indexOf(item) !== -1;
    },

    _isItemCollapsed: function(item) {
      if (!item || !this.collapsedItems || !Array.isArray(this.collapsedItems)) return false;
      return this.collapsedItems.indexOf(item) !== -1;
    },

    _itemVisibilityChanged: function() {
      this.debounce('item-visibility-changed', function(){
        const visibleEl = Polymer.dom(this.root).querySelector('#visible');
        const collapsedEl = Polymer.dom(this.root).querySelector('#collapsed');
        if (visibleEl) visibleEl.render();
        if (collapsedEl) collapsedEl.render();
      });
      // if (this.$.visible)   this.async(function(){ this.$.visible.render(); });
      // if (this.$.collapsed) this.async(function(){ this.$.collapsed.render(); });
      // if (this.$.visible)   this.$.visible.render();
      // if (this.$.collapsed) this.$.collapsed.render();
    },

    _getSelectedItemLabel: function() {
       return (this.selectedItem && this.selectedItem.label) ? this.selectedItem.label : this.unselectedText;
    },

    _handleCollapseAllChanged: function(nextVal, lastVal) {
      if (this.collapseAll) {
        this.rebuild();
      }
      if (!this.collapseAll) {
        this._availableWidth = null; // Forces width to notify changes
        this._sizeChanged();
      }
    },

    _handleItemTapped: function(evt) {
      if (!evt.detail.path || !Array.isArray(evt.detail.path) || !evt.detail.path.length) return;

      if (evt.detail.path.length === 1) {
        this.set('selectedPath', evt.detail.path[0]);
        this.set('selectedSubpath', null);
      }
      if (evt.detail.path.length === 2) {
        this.set('selectedPath', evt.detail.path[0]);
        this.set('selectedSubpath', evt.detail.path[1]);
      }
    },

    _selectedPathChanged() {
      this.debounce('selected-path-changed', ()=>{
        // 1. Find the items
        let path = !this.selectedSubpath ? this.selectedPath : `${this.selectedPath}.${this.selectedSubpath}`;
        let [item, subitem] = this._findItemByPath(path);
        if (item) {
          this._setSelectedItem(item);
          this._setSelectedSubitem(subitem);
          return;
        }

        // 2. If no items found, try the fallback
        if (!item && this.fallbackPath && this.fallbackPath !== this.selectedPath) {
          this.set('selectedPath', this.fallbackPath);
          this.set('selectedSubpath', this.fallbackSubpath || null);
        }

        // 3. Fallback path can't be found either
        console.log(`Could not find an item matching the path ${path}.`)
      });
    },

    _findItemByPath(pathStr) {
      let items = [null,null];
      if (typeof this._paths === 'object' && this._paths.hasOwnProperty(pathStr)) {
        items[0] = this._paths[pathStr][0];
        items[1] = this._paths[pathStr][1] || null;
      }
      return items;
    },

    created: function() {
      this._navAttached = false;
      // this._navTarget;
    },

    attached: function() {
      this._navAttached = true;
      // this._knownItems = [];
      // this._detachedItems = [];
      // var boundItemHandler = this._handleItemsDistributed.bind(this);
      // this._itemObserver = Polymer.dom(this.$.new).observeNodes(boundItemHandler);
    },

    detached: function() {
      this._navAttached = false;
      // this._knownItems = null;
      // this._detachedItems = null;
      // Polymer.dom(this.$.new).unobserveNodes(this._itemObserver);
    },

    _sizeChanged: function() {
      if (this.collapseAll) return;

      const debouncer = 'measure-available-width';
      if (typeof this._availableWidth !== 'number') {
        this._getAvailableWidth();
        return;
      }
      if (this.isDebouncerActive(debouncer)) {
        this.cancelDebouncer(debouncer);
      }
      this.debounce(debouncer, this._getAvailableWidth.bind(this), 100);
    },

    _getAvailableWidth: function() {
      window.requestAnimationFrame(() => {
        const el = this.$.items;
        if (!el) return;
        const width = el.getBoundingClientRect().width;
        if (this._availableWidth !== width) this.set('_availableWidth', width);
      });
    },

    _handleNavItemsChanged(items) {
      const paths = this._paths = this._getItemPaths(items);
      this.rebuild();
    },

    _getItemPaths(items, parent, paths={}) {
      for (let item of items) {
        let pathKey = parent ? `${parent.path}.${item.path}` : item.path;
        if (paths[pathKey]) {
          console.log(`ERR: Path ${pathKey} is not unique. All paths must be unique.`);
        }
        else if (parent) {
          paths[pathKey] = [parent, item];
        }
        else {
          paths[pathKey] = [item];
        }

        if (item.subitems) {
          this._getItemPaths(item.subitems, item, paths);
        }
      }

      return paths;
    },

    _handleItemsDistributed: function(info) {
      // if (Array.isArray(info.addedNodes) && info.addedNodes.length) {
      //   var addedItems = this._findItemNodes(info.addedNodes);
      //   this._newItems = this._newItems.concat(addedItems);
      //   this.rebuild();
      // }
      //
      // if (Array.isArray(info.removedNodes) && info.removedNodes.length) {
      //   var removedItems = this._findItemNodes(info.removedNodes);
      //   this._knownItems = this._untrackItems(removedItems);
      // }
    },

    /**
     * Rebuilds the nav to reflect its `type` and `collapseAll` settings.
     */
    rebuild: function() {
      if (!this.navItems || !Array.isArray(this.navItems) || this._pendingRender || (!this.collapseAll && typeof this._availableWidth !== 'number')) return;

      if (this.collapseAll || this._availableWidth === 0) {
        this._setVisibleItems([]);
        this._setCollapsedItems(this.navItems.slice(0));
        return;
      }

      const measurements = this._measureItems(this.navItems);
      const {visible, collapsed} = this._fitItems(this.navItems, this._availableWidth, measurements);
      this._setVisibleItems(visible);
      this._setCollapsedItems(collapsed);
      this.notifyPath('visibleItems.*');
      this.notifyPath('collapsedItems.*');

      // if (this._pendingRender || typeof this.collapseAll !== 'boolean' || !Array.isArray(this._knownItems) || !this._knownItems.length) return;
      // this._pendingRender = true;
      //
      // const items = this._knownItems;
      // const width = this.collapseAll ? 0 : this._availableWidth;
      //
      // this._getFittedItems(items, width)
      //   .then(({visible, collapsed}) => {
      //     this._updateItemsProp('visibleItems', visible.map(node=>node.item), true);
      //     this._updateItemsProp('collapsedItems', collapsed.map(node=>node.item), true);
      //     return Promise.resolve({visible, collapsed});
      //   })
      //   .then(({visible, collapsed}) => this._renderItems(items, visible, collapsed))
      //   .then(({visible, collapsed}) => {
      //     this._pendingRender = false;
      //     // this._updateItemsProp('visibleItems', visible.map(node=>node.item), true);
      //     // this._updateItemsProp('collapsedItems', collapsed.map(node=>node.item), true);
      //     return Promise.resolve();
      //   });

      //
      // const pMeasure = () => (width>0) ? this._measureItems(items);
      // const pFit = (measurements) => this._fitItems(items, width, measurements);
      // const pRender = ({visible, collapsed}) => this._renderItems(items, visible, collapsed);
      // const pFinish = ({visible, collapsed}) => {
      //   this._pendingRender = false;
      //   this._updateItemsProp('visibleItems', visible.map(node=>node.item), true);
      //   this._updateItemsProp('collapsedItems', collapsed.map(node=>node.item), true);
      //   return Promise.resolve();
      // };
      // const pAll = () => pMeasure().then(pFit).then(pRender).then(pFinish);
      //
      // // Polymer.RenderStatus.afterNextRender(this, pAll);
      // pAll.call();
    },

    _getFittedItems(items, width) {
      if (width <= 0) {
        return Promise.resolve({ visible: [], collapsed: items.slice(0) })
      }
      return this._measureItems(items).then(measurements => this._fitItems(items, width, measurements));
    },

    _updateItemsProp(propName, items, readOnly) {
      const setter = readOnly ? this[`_set${propName.slice(0,1).toUpperCase()}${propName.slice(1)}`].bind(this) : this.set.bind(this, propName);
      if (items.length) {
        setter(items);
      } else {
        setter([]);
      }
      if (this[propName] && Array.isArray(this[propName])) {
        const splices = Polymer.ArraySplice.calculateSplices(this[propName], items);
      }
    },

    _renderItems: function(items, visible, collapsed) {
      let renderers;
      if (items.length && !visible.length && collapsed.length) {
        // If all items are collapsed, move to the dropdown
        let parent = this.$$('#collapsedGroup');
        renderers = items.map(item => this._moveToParent(item, parent));
      }
      else {
        // Otherwise distribute to the right location
        let collapsedParent = this.$.collapsed;
        let visibleParent = this.$.visible;
        renderers = items.map(item =>
          this._moveToParent(item, (collapsed.indexOf(item) === -1) ? visibleParent : collapsedParent)
        );
      }
      return Promise.all(renderers).then(() => ({ items: items, visible: visible, collapsed: collapsed }));
    },

    _renderItem: function(item, isCollapsed=false) {
      // const newParent = isCollapsed ? this.$.collapsed : this.$.visible;
      // const currentParent = Polymer.dom(item).parentNode;
      // if (!currentParent) {
      //   Polymer.dom(newParent).appendChild(item);
      // }
      // if (currentParent && currentParent !== newParent) {
      //   Polymer.dom(currentParent).appendChild(item);
      //   Polymer.dom(newParent).appendChild(item);
      // }
      // return Promise.resolve();
    },

    _moveToParent(node, newParent) {
      const currentParent = Polymer.dom(node).parentNode;
      if (!currentParent) {
        Polymer.dom(newParent).appendChild(node);
      }
      if (currentParent && currentParent !== newParent) {
        Polymer.dom(currentParent).removeChild(node);
        Polymer.dom(newParent).appendChild(node);
      }
      return Promise.resolve();
    },

    _fitItems: function(items, width, measurements) {
      let available = width;

      // If the first item is larger than the available, collapse all
      if (available < measurements[0]) {
        return { visible: [], collapsed: items.slice(0) };
      }

      // Try to fit items in the available space
      let i = 0;
      let len = items.length;

      while (i<len && available>0) {
        if (measurements[i] > available) {
          break;
        }
        available -= measurements[i];
        i++;
      }

      // If any overflow, ensure the overflow icon can fit
      let overflowSize = this.statics.OVERFLOW_ICON_SIZE + this.statics.OVERFLOW_ICON_PADDING;
      if (i !== len && available < overflowSize) {
        available -= overflowSize;
        while (i>0 && available<0) {
          available += measurements[i];
          i--;
        }
      }
      return { visible: items.slice(0,i), collapsed: items.slice(i) };
    },

    _measureItems: function(items) {
      const boundMeasureFn = this._measureItem.bind(this);
      return items.map(boundMeasureFn);
    },

    _measureItem: function(item) {
      const textLength = this._measureText(item.label, this.statics.ITEM_FONT_NAME, this.statics.ITEM_FONT_SIZE + 'px');
      if (!textLength) return;
      let totalLength = textLength; /* start with text size */
      totalLength += this.statics.ITEM_PADDING; /* add left pad + right pad */
      if (item.icon && item.icon.length) totalLength += (this.statics.ITEM_ICON_WIDTH + this.statics.ITEM_ICON_PADDING); /* add icon size + icon right pad */
      if (item.subitems && item.subitems.length) totalLength += (this.statics.OPEN_ICON_WIDTH + this.statics.OPEN_ICON_PADDING); /* add dropdown icon size + dropdown icon left pad */
      return totalLength;
    },

    _measureText: function(text, fontName, fontSize) {
      var cv = this._get2dMeasureCanvas(fontName, fontSize);
      var size = cv.measureText(text).width;
      return isNaN(size) ? undefined : Math.round(size);
    },

    _get2dMeasureCanvas: function(fontName, fontSize) {
      this.__measureCanvasCache = this.__measureCanvasCache || {};
      var fontInfo = fontSize + ' ' + fontName;
      if (this.__measureCanvasCache[fontInfo]) return this.__measureCanvasCache[fontInfo];
      var cv = document.createElement('canvas');
      cv.height = 999;
      cv.width = 999;
      var ctx = cv.getContext('2d');
      ctx.font = fontInfo;
      return (this.__measureCanvasCache[fontInfo] = ctx);
    },

    _attachChild(child) {
      Polymer.dom(this.$.visible).appendChild(child);
    },

    _rebuildItems: function() {

    },

    _moveToTarget: function(el, lastParent, nextParent) {
      // if (!el || !lastParent || !nextParent) return;
      //
      // Polymer.dom(lastParent).removeChild(el);
      // Polymer.dom(nextParent).appendChild(el);
    },

    _ensureItemsInTarget(items, target) {
      // var i = 0;
      // var len = items.length;
      // var parentNode;
      // var anyMoved = false;
      //
      // for (; i < len; i++) {
      //   parentNode = Polymer.dom(items[i]).parentNode;
      //   if (parentNode && parentNode !== target) {
      //     Polymer.dom(parentNode).removeChild(items[i]);
      //     Polymer.dom(target).appendChild(items[i]);
      //     anyMoved = true;
      //   }
      // }
      //
      // if (anyMoved) {
      //   Polymer.dom.flush();
      // }
    },

    _getNavTarget: function(collapseAll, vertical) {
      // if (collapseAll && !vertical) {
      //   return this.$.collapseAll;
      // }
      // if (!collapseAll && !vertical) {
      //   return this.$.horizontal;
      // }
      // return this.$.vertical;
    },

    /**
     * Handles selection events that bubble up from subcomponents.
     */
    _handlePathSelected: function(evt) {
      // var path = evt.detail.path || [];
      // if (path.length) {
      //   var pathStr = '';
      // }
    },

    /**
     * Selects an item by its path or its index.
     *
     * To select an item, just provide its path. For example, select the Dashboards
     * item (which has path 'dashboards') with `select('dashboards')`
     *
     * To select an item inside a group, provide a sub-path. For example, select
     * the first case (which has path 'case1') inside the Cases group (which has
     * path 'cases') with `select('cases.case1')`.
     *
     * Note that individual path names cannot have dots ('.') in them or they
     * cannot be selected.
     *
     * If an item is found, it will be returned after it is selected. If no item
     * is found, return will be undefined.
     *
     * @param {Number|String} item
     * @return {HTMLElement|undefined}
     */
    select: function(item) {
      var selectedItem;

      // If a string as a trailing dot ('foo.') clean the dot off
      if (typeof item === 'string' && item.length > 0 && item.indexOf('.') === (item.length - 1)) {
        item = item.substr(0, (item.length - 1));
      }
      // If the item is a string with subpaths, split and select each
      if (typeof item === 'string' && item.length && item.indexOf('.') !== -1) {
        item = item.split('.');
        selectedItem = this._selectItems(item);
      }
      else if (typeof item === 'string' && item.length) {
        selectedItem = this._selectItem(item, 'path');
      }
      else if (typeof item === 'number') {
        selectedItem = this._selectItem(item, 'index');
      }

      return selectedItem;
    },

    /**
     * Selects an item directly. If an (item[prop] === val), the item will be
     * selected. If an item is found, it will be returned after it is selected.
     * If no item is found, return will be undefined.
     *
     * @return {HTMLElement|undefined}
     */
    _selectItem(val, prop) {
      var items = this.$.selector.items;
      if (!items || !items.length) return;

      var itemToSelect = this._findItem(items, val, prop);
      if (itemToSelect && !itemToSelect.selected) {
        itemToSelect.set('selected', true);
      }

      return itemToSelect;
    },

    /**
     * Selects an item inside a group. `refs[0]` should be an index or path of
     * a group. `refs[1]` should be an index or path of an item in that group.
     *
     * If an item is found, it will be returned after it is selected. If no item
     * is found, return will be undefined.
     *
     * @return {HTMLElement|undefined}
     */
    _selectItems(refs) {
      var items = this.$.selector.items;
      if (!items || !items.length) return;

      // Convert the group or item ref to a number, if it can be converted.
      // Otherwise it will stay a string.
      var groupRef = this._castStrToNum(refs[0]);
      var itemRef = this._castStrToNum(refs[1]);

      var groupToSelect = this._findItem(items, groupRef, (typeof groupRef === 'string') ? 'path' : 'index');
      var itemToSelect;
      if (groupToSelect && (typeof groupToSelect.select === 'function')) {
        selectItem = groupToSelect.select(itemRef);
      }

      return itemToSelect;
    },

    /**
     * Finds and returns an item that passes the test `item[prop] === val` or
     * returns undefined.
     *
     * @param {Array} items - An array of `HTMLElement` to search
     * @param {String|Number} val
     * @param {String} prop - The property to check
     * @returns {HTMLElement|undefined}
     *
     */
    _findItem(items, val, prop) {
      var found;
      var i = 0;
      var len = items.length;

      for (; i<len; i++) {
        if (typeof items[i][prop] !== 'undefined' && items[i][prop] === val) {
          found = items[i];
          break;
        }
      }

      return found;
    },

    /**
     * If the string can be casted to a number, casts it. Otherwise, returns
     * the original string.
     */
    _castStrToNum: function(str) {
      return (typeof str === 'string' && !isNaN(str)) ? parseInt(str) : str;
    },


    /**
     * Helps check if items generated from data have subitems.
     */
    _hasSubitems(item) {
      return item && Array.isArray(item.subitems) && item.subitems.length;
    },

    /**
     * Helps check if items generated from data have subitems.
     */
    _hasNoSubitems(item) {
      return !item.hasOwnProperty('subitems');
    },

    _getNavClasses(collapseAll, vertical) {
      let className = ['app-nav'];

      if (vertical) {
        className.push('app-nav--vertical');
      }
      if (!vertical) {
        className.push('app-nav--horizontal');
      }
      if (collapseAll === true) {
        className.push('app-nav--horizontal');
      }

      return className.join(' ');
    },

    _navIs(isType, wantedType, isCollapsed, wantedCollapsed) {
      // If nav should be collapsed and it is not, return false...
      if (typeof wantedCollapsed === 'string' && wantedCollapsed === 'collapsed' && !isCollapsed) {
        return false;
      }
      // Next, check type
      if (wantedType === 'horizontal' && isType !== 'horizontal') {
        return false;
      }
      if (wantedType === 'vertical' && isType !== 'vertical') {
        return false;
      }
      return true;
    },

    _someCollapsed(collapsed, visible) {
      return Array.isArray(collapsed) && collapsed.length > 0;
    },

    _allCollapsed(collapsed, visible) {
      return Array.isArray(collapsed) && collapsed.length > 0 && Array.isArray(visible) && visible.length === 0;
    },

    _ifAnyCollapsed(className, collapsedItems) {
      // if (collapsedItems && Array.isArray(collapsedItems) && collapsedItems.length) {
      //   return className;
      // }
    },

    _ifSelectedCollapsed(selectedItem, collapsedItems) {
      if (!selectedItem || !collapsedItems || !Array.isArray(collapsedItems) || !collapsedItems.length) return false;
      return collapsedItems.indexOf(selectedItem) !== -1;
    }
  });
</script>
