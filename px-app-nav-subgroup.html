<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../px-polymer-font-awesome/px-polymer-font-awesome.html"/>
<link rel="import" href="../iron-dropdown/iron-dropdown.html"/>
<link rel="import" href="../neon-animation/neon-animations.html"/>
<link rel="import" href="../neon-animation/neon-animation-behavior.html"/>
<link rel="import" href="../neon-animation/neon-animation-runner-behavior.html"/>

<link rel="import" href="px-app-nav-item.html"/>
<link rel="import" href="css/px-app-nav-subgroup-styles.html"/>

<dom-module id="px-app-nav-subgroup">
  <template>
    <style include="px-app-nav-subgroup-styles"></style>

    <px-app-nav-item
        id="itemButton"
        icon="{{icon}}"
        label="{{label}}"
        dropdown="{{!hideDropdownIcon}}"
        selected$="{{_isGroupSelected(selected, noHighlight)}}"
        collapsed$="{{collapsed}}">
    </px-app-nav-item>

    <div class="app-nav-subgroup__dropdown" id="groupcontainer">
      <div class="app-nav-subgroup__dropdown__content" id="groupcontent">
        <content select="*"></content>
      </div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'px-app-nav-subgroup',

    behaviors: [
      Polymer.NeonAnimationRunnerBehavior
    ],

    properties: {
      /**
       * If `true`, one of the group's subitems is selected.
       *
       * Watch for updates to find out when the group becomes selected through
       * user interaction or through automatic selection.
       *
       * Set the `selected` attribute on one of the group's subitems to select
       * this group.
       */
      selected: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true,
        observer: '_handleSelectedChanged'
      },

      /**
       * The label text for the group's button.
       */
      label: {
        type: String
      },

      /**
       * The icon for the group's button. Should be a valid font awesome icon
       * name (e.g. 'fa-briefcase').
       */
      icon: {
        type: String
      },

      /**
       * A named path for this item. Used to select one of its subitems programatically,
       * e.g. by binding to the current URL route. Path names cannot have a dot
       * ('.') in them or they will not work.
       */
      path: {
        type: String,
        reflectToAttribute: true
      },

      /**
       * The select subitem's element, if a subitem is selected.
       */
      selectedSubitem: {
        type: HTMLElement,
        notify: true
      },

      /**
       * The selected subitem's path, if a subitem is selected.
       */
      selectedSubpath: {
        type: (String|Number),
        notify: true
      },

      /**
       * If `true` the group is expanded so the user can select a subitem.
       */
      opened: {
        type: Boolean
      },

      minWidth: {
        type: Number
      },

      hideDropdownIcon: {
        type: Boolean,
        value: false
      },

      animationConfig: {
        type: Array,
        value: function() {
          return {
            'open' : {
              name: 'expand-subgroup-animation',
              node: this.$.groupcontainer,
              endHeightNode: this.$.groupcontent,
              timing: {
                duration: 200,
                easing: 'ease-in'
              }
            },
            'close' : {
              name: 'contract-subgroup-animation',
              node: this.$.groupcontainer,
              startHeightNode: this.$.groupcontent,
              timing: {
                duration: 200,
                easing: 'ease-out'
              }
            }
          }
        }
      }
    },

    listeners: {
      'neon-animation-finish': '_onNeonAnimationFinish'
    },

    attached: function() {
      this._lastOpenedSubgroup = null;
      this._openedSubgroup = null;
      this.listen(this.$.itemButton, 'tap', '_handleSelfTapped');
      // this.listen(this.$.group, 'iron-overlay-opened', '_handleDropdownOpened');
      // this.listen(this.$.group, 'iron-overlay-closed', '_handleDropdownClosed');
      // this.listen(this.$.group, 'iron-dropdown-animating-open', '_handleDropdownWillOpen');
      // this.listen(this.$.group, 'iron-dropdown-animating-closed', '_handleDropdownWillClose');
      this.listen(this.$.groupcontainer, 'px-app-nav-item-tapped', '_handleSubitemSelected');
      // this.listen(this.$.group, 'px-app-nav-subgroup-opened', '_handleSubgroupOpened');
      // this.listen(this.$.group, 'px-app-nav-subgroup-closed', '_handleSubgroupClosed');
    },

    detached: function() {
      this.unlisten(this.$.itemButton, 'tap', '_handleSelfTapped');
      // this.unlisten(this.$.group, 'iron-overlay-opened', '_handleDropdownOpened');
      // this.unlisten(this.$.group, 'iron-overlay-closed', '_handleDropdownClosed');
      // this.unlisten(this.$.group, 'iron-dropdown-animating-open', '_handleDropdownWillOpen');
      // this.unlisten(this.$.group, 'iron-dropdown-animating-closed', '_handleDropdownWillClose');
      this.unlisten(this.$.groupcontainer, 'px-app-nav-item-tapped', '_handleSubitemSelected');
      // this.unlisten(this.$.group, 'px-app-nav-subgroup-opened', '_handleSubgroupOpened');
      // this.unlisten(this.$.group, 'px-app-nav-subgroup-closed', '_handleSubgroupClosed');
    },

    _handleDropdownOpened(evt) {
      evt.preventDefault();
      evt.stopPropagation();

      const content = Polymer.dom(this.root).querySelector('#groupcontent');
      const detail = {};
      if (content) {
        const rect = content.getBoundingClientRect()
        detail.dropdownHeight = rect.height;
        detail.dropdownWidth = rect.width;
      }

      this.fire('px-app-nav-subgroup-opened', detail);
    },

    _handleDropdownClosed(evt) {
      evt.preventDefault();
      evt.stopPropagation();

      this.fire('px-app-nav-subgroup-closed');
    },

    _handleSubgroupOpened(evt) {
      if (!this.superlist) return;

      const subgroup = Polymer.dom(evt).rootTarget;

      if (this._openedSubgroup && this._openedSubgroup !== subgroup) {
        this._lastOpenedSubgroup = this._openedSubgroup;
        this._openedSubgroup.closeGroup();
      }

      this._openedSubgroup = subgroup;
      subgroup.style.marginBottom = (evt.detail.dropdownHeight || 0) + 'px';
    },

    _handleSubgroupClosed(evt) {
      if (!this.superlist) return;
      const subgroup = Polymer.dom(evt).rootTarget;
      subgroup.style.marginBottom = null;
      if (this._openedSubgroup !== subgroup) {
        this._openedSubgroup.position();
      } else {
        this._openedSubgroup = null;
      }
    },

    _handleDropdownWillOpen(evt) {
      if (!this.collapsed) return;
      this.animationConfig.open.addHeight = evt.detail.newHeight;
      this.playAnimation('open');
    },

    _handleDropdownWillClose(evt) {
      if (!this.collapsed) return;
      this.animationConfig.close.subtractHeight = evt.detail.oldHeight;
      this.playAnimation('close');
    },

    _getGroupClasses() {
      if (this.superlist) {
        return 'app-nav-group__dropdown--superlist';
      }
      return 'app-nav-group__dropdown--sublist';
    },

    /**
     * Checks if a property is the desired `type`.
     *
     * @param {*} prop
     * @returns {Boolean}
     */
    _propIsTypeOf(prop, type) {
      return prop && type && (typeof prop === type);
    },

    _toggleGroup() {
      if (this.opened) {
        this.closeGroup();
      } else {
        this.openGroup();
      }
    },

    openGroup() {
      this.opened = true;
      this.playAnimation('open');
    },

    closeGroup() {
      this.opened = false;
      this.playAnimation('close');
    },

    _onNeonAnimationFinish(evt) {
      if (this.opened) {
        this.$.groupcontainer.style.height = this.$.groupcontent.getBoundingClientRect().height + 'px';
      } else {
        this.$.groupcontainer.style.height = '0px';
      }
    },

    /**
     * When the user clicks on a group, toggle the group's dropdown menu
     * so the user can to select a subitem.
     */
    _handleSelfTapped(evt) {
      this._toggleGroup();
    },

    /**
     * If the dropdown is cancelled (about to close) but the cancel event comes
     * from a click on target element, stop the cancel so we can handle it
     * through the click handler on the target element.
     *
     * Thanks to paper-menu-button for the guidance on how to best handle this.
     */
    _handleGroupCanceled(evt) {
      var uiEvt = evt.detail;
      var target = Polymer.dom(uiEvt).rootTarget;
      var trigger = this;
      var path = Polymer.dom(uiEvt).path;

      if (path.indexOf(trigger) > -1) {
        evt.preventDefault();
      }
    },

    /**
     * If a group's subitem is selected, it should also be selected. Fire an event
     * to ask this item's parent to select it when its subitem is selected.
     */
    _handleSubitemSelected(evt) {
      if (!this.superlist) {
        evt.preventDefault();
        evt.stopPropagation();

        var localPath = this.path ? this.path : (typeof this.index === 'number' ? this.index : this.item);
        var path = [localPath].concat(evt.detail.path);
        var items = [this.item].concat(evt.detail.items);

        this.fire('px-app-nav-item-tapped', {
          group: true,
          path: path,
          items: items
        });
      }

      if (!this.collapsed) {
        this.closeGroup();
      }
    },

    /**
     * If a group is goes from being selected to deselected, set its selected
     * subitem to null to clear the selected and call closeGroup to ensure
     * it is closed.
     */
    _handleSelectedChanged(nextState, lastState) {
      if (lastState === true && nextState === false) {
        this.closeGroup();
      }
    },

    _getPositionTarget() {
      return this.$.itemButton;
    },

    _isGroupSelected(isSelected, noHighlight) {
      if (isSelected && !noHighlight) {
        return true;
      }
      return false;
    }
  });

  Polymer({
    is: 'expand-subgroup-animation',
    behaviors: [
      Polymer.NeonAnimationBehavior
    ],
    configure: function(config) {
      var node = config.node;
      var endHeightNode = config.endHeightNode;
      var height = endHeightNode.getBoundingClientRect().height;
      // var group = config.groupNode;
      // var currentHeight = node.getBoundingClientRect().height;
      // var hiddenGroupHeight = group.getBoundingClientRect().height;
      // var targetHeight = currentHeight + hiddenGroupHeight;
      this._effect = new KeyframeEffect(node, [{
        height: '0px'
      }, {
        height: height + 'px'
      }], this.timingFromConfig(config));
      return this._effect;
    }
  });

  Polymer({
    is: 'contract-subgroup-animation',
    behaviors: [
      Polymer.NeonAnimationBehavior
    ],
    configure: function(config) {
      var node = config.node;
      var startHeightNode = config.startHeightNode;
      var height = startHeightNode.getBoundingClientRect().height;
      // var group = config.groupNode;
      // var currentHeight = node.getBoundingClientRect().height;
      // var visibleGroupHeight = group.getBoundingClientRect().height;
      // var targetHeight = currentHeight - visibleGroupHeight;
      this._effect = new KeyframeEffect(node, [{
        height: height + 'px'
      }, {
        height: '0px'
      }], this.timingFromConfig(config));
      return this._effect;
    }
  });
</script>
